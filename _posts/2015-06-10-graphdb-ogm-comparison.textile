---
layout: post
title: Graph Database Java OGM Comparision
date: 2015-06-10 18:00:00 +00:00
tags: 
- java
- neo4j
- graphdb
- ogm
---

For sometime i have been using "Neo4j":http://neo4j.com/ in combination with "Spring Data Neo4j (SDN)":http://projects.spring.io/spring-data-neo4j/. As the name suggests when using SDN you are bound to use Neo4j.
But there are alternatives to which we'll get in a moment.

There are also a few other databases around which are pretty neat. My list only includes Java based graph databases that allow embedding.

# Graph Databases

## Neo4j

"Neo4j":http://neo4j.com/ was the first graph database i have ever used. It is "open source":https://github.com/neo4j and very fast. It also ships directly with a neat little admin ui which can be used to visualize your graph data.
The database is very easy to embedd and comes with a powerful query language (cypher). I don't know whether there are any other dedicated OGM/ORM layers for Neo4j besides of SDN.
The licensing on the other hand is not very useful once you decide to embedd neo4j in your application. 
Neo4j Community Edition is licensed under GPL. MySQL is also licensed under GPL. 
This means when you would not embedd the database and only use the provided Neo4j REST API you would not need to license your application under GPL.
Once you embedd the database in your application you must license your application under GPL. This gets even worse when you decide to utilze the clustering features. In this case you would need to license your application under AGPL (even if you would use neo4j though the REST API)

## OrientDB

"OrientDB":http://orientdb.com/ is also open source. There is no cypher but you can use Orient SQL. Embedding is also very easy and the licensing with Apache 2 license is also very developer friendly.
  
## Sparsity Sparksee

I have never used "Sparsity Sparksee":http://www.sparsity-technologies.com/ but feature wise it is compareable to the other big graph databases.

## Titan DB

"Titan DB":http://thinkaurelius.github.io/titan/ is an interessting database. 
The storage layer for this graph database is interchangeable. You can use "Berkeley DB":http://en.wikipedia.org/wiki/Berkeley_DB which is quiet fast but it basically limits the size of nodes you can store and you can't use clustering.
Alternativly you can also use "Cassandra":http://cassandra.apache.org/. Cassandra is slower compared to BerkeleyDB but it supports replication.

## Hypergraphdb

I have never used this database and can't say much about it but my impression is that it is very small and the feature set is limited.

# Performance comparison

The performance comparision is very superficial and you should keep in mind that the usecase for the database should always dictate the choice. 
I have just compared low level read and write speed because i was interessted in those.
The benchmark does not cover any kind of graph traversals.
I was merely interessted in the speed it takes each database to output a single node.
All tests were executed in a jvm that also ran the graph database. I created 10k nodes and read those 10k nodes sequentially and in random order. No warmup phase was added. 
As a baseline i choose neo4j because it got the overall best performance.

|_. DB                  |_. write 10k |_. read 10k seq |_. read 10k random |
| Neo4j                 | 100%        | 100%           | 100%              |
| OrientDB              | 171%        | 101%           | 104%              |
| Titan DB (Cassandra)  | 314%        | 502%           | 510%              |
| Titan DB (BerkeleyDB) | -           | 200%           | 205%              |

# OGM - Object Graph Mapping

## Spring Data Neo4j 

I have used SDN a lot and i'm quiet impressed by it. Getting started is quiet easy and there are a lot of examples out there.
When talking about SDN it is important to note the differences between the versions. SDN 3.3x is currently only supported for Neo4j 2.1.x while SDN 4.x also supports the newly releases Neo4j version 2.x.

### 3.3.x

{% snippet java %}
@NodeEntity
public class User extends AbstractPersistable {

	private String lastname;

	private String firstname;

	@Indexed(unique = true)
	private String username;

  @RelatedTo(type = "MEMBER_OF", direction = Direction.OUTGOING, elementClass = Group.class)
	private Set<Group> groups = new HashSet<>();
}
{% endsnippet %}

SDN uses annotations to map the entities and relationships. Inheritance of objects is direcly mapped to the labels of a node.
It is possible to create sping data repositories that retrieve objects by using property values or by specifiy cypher statements.

What i like is the paging cypher support. What i did not like is the amount of classes and interfaces you need to create to interface with your objects but i guess this is always application specific.
The @Fetch annotation also did cause a lot of trouble for me. SDN would load the full entity (groups) when adding the @Fetch annotation to the groups set in the example above. This could cause to infinitive recursions and huge loading times. 
At the end i removed nearly all @Fetch annotations from my projects. Instead i did use the "Neo4jTemplate":http://docs.spring.io/autorepo/docs/spring-data-neo4j/current/api/org/springframework/data/neo4j/support/Neo4jTemplate.html class in order to populate the returned enitity. When no @Fetch was specified only a shallow object with no properties is returned. Using the neo4jTemplate.fetch() this shallow object could be loaded.

Additionally SDN 3.x was/is slow as hell when using a remote Neo4j instead of the embedded one. This is another reason why SDN 4.x was developed.

### 4.x

SDN 4.x is currently is not using the Neo4j Core API directly. Instead it relies on the Neo4j REST API. The overall performance for remote connected neo4j servers is faster (compared to SDN 3.3 in remote mode).
I can only guess why Neo4j/Pivotal Software choose this approach but my guess is that they started a rewrite of SDN in preparation for the binary protocol support for neo4j and to speedup SDN when using a remote Neo4j. 

## Tinkerpop

"Tinkerpop":http://tinkerpop.incubator.apache.org/ is a collection of APIs that are allow transparent and easy interfacing with graph databases.
The blueprint API is the most low level api which is used to wrap the graph databases native API. By doing so it provides a standarized API which other APIs can use to interface with a graph db through this API layer. 
The API layer is very thin. There are various wrappers for many graph databases. I have used the "blueprint neo4j implementation":https://github.com/tinkerpop/blueprints/tree/master/blueprints-neo4j2-graph.

Tinkerpop Blueprint is generally a good choice when you want to develop your application but you are not yet sure what graph database you will use at the end.

There are three OGM's that are based upon the blueprint API i have looked at.

### Tinkerpop 2 - Frames

The Frames API uses annotations similar to SDN and thus switching from SDN to Frames is not that hard. Indices have to be created seperatly. Tinkerpop does not support cypher. You would need to write your "statements in gremlin":http://sql2gremlin.com/ instead.

{% snippet java %}
public interface User extends AbstractPersistable {

        @Property("firstname")
        public String getFirstname();

        @Property("firstname")
        public void setFirstname(String name);

        @Property("lastname")
        public String getLastname();

        @Property("lastname")
        public void setLastname(String name);

        @Property("username")
        public String getUsername();

        @Property("username")
        public void setUsername(String name);

        @Adjacency(label = "HAS_USER", direction = Direction.OUT)
        public Iterable<Group> getGroups();
}
{% endsnippet %}

### Tinkerpop - totorom

I guess "Totorom":https://github.com/BrynCooke/totorom could be seen as a successor to Frames. It is faster compared to Frames and it nativly interfaces with the tinkerpop gremlin query API.
The whole OGM is also very small. Many (all?) annotations are gone. Instead of interfaces you write classes which make thinks a lot easier compared to frames. In frames custom method handlers would need a special annotation (@JavaHandler) and a dedicated handler implementation for the method. With Totorom you just add your custom method.

{% snippet java %}
public class User extends AbstractPersistable {

        public static String FIRSTNAME_KEY = "firstname";

        public static String LASTNAME_KEY = "lastname";

        public static String USERNAME_KEY = "username";

        public String getFirstname() {
                return getProperty(FIRSTNAME_KEY);
        }

        public void setFirstname(String name) {
                setProperty(FIRSTNAME_KEY, name);
        }

        public String getLastname() {
                return getProperty(LASTNAME_KEY);
        }

        public void setLastname(String name) {
                setProperty(LASTNAME_KEY, name);
        }

        public String getUsername() {
                return getProperty(USERNAME_KEY);
        }

        public void setUsername(String name) {
                setProperty(USERNAME_KEY, name);
        }

        public List<Group> getGroups() {
                return out("HAS_USER").toList(Group.class);
        }

}
{% endsnippet %}


### Ferma

The API of "Ferma":https://github.com/Syncleus/Ferma is very similar to Totorom. Ferma has various operation modes. It also supports the Frames annotations.

{% snippet java %}
public class User extends AbstractPersistable {

        public static String FIRSTNAME_KEY = "firstname";

        public static String LASTNAME_KEY = "lastname";

        public static String USERNAME_KEY = "username";

        public String getFirstname() {
                return getProperty(FIRSTNAME_KEY);
        }

        public void setFirstname(String name) {
                setProperty(FIRSTNAME_KEY, name);
        }

        public String getLastname() {
                return getProperty(LASTNAME_KEY);
        }

        public void setLastname(String name) {
                setProperty(LASTNAME_KEY, name);
        }

        public String getUsername() {
                return getProperty(USERNAME_KEY);
        }

        public void setUsername(String name) {
                setProperty(USERNAME_KEY, name);
        }

        public List<Group> getGroups() {
                return out("HAS_USER").toList(Group.class);
        }

}
{% endsnippet %}
