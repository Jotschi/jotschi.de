<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ardunio on Jotschi&#39;s Blog</title>
    <link>http://jotschi.de/tags/ardunio/</link>
    <description>Recent content in Ardunio on Jotschi&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 21 Apr 2012 12:59:27 +0000</lastBuildDate>
    <atom:link href="http://jotschi.de/tags/ardunio/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Arduino Ethernet Shield Simple REST API Example</title>
      <link>http://jotschi.de/2012/04/21/arduino-ethernet-shield-simple-rest-api-example/</link>
      <pubDate>Sat, 21 Apr 2012 12:59:27 +0000</pubDate>
      
      <guid>http://jotschi.de/2012/04/21/arduino-ethernet-shield-simple-rest-api-example/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I&amp;#8217;m currently developing a small home security system. The arduino + ethernet shield will provide the rest api control interface for the system. Later on that interface will be controllable with my android phone. (I&amp;#8217;ll probably write another post about that).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I took the &lt;a href=&#34;http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1284844153&#34;&gt;webserver example&lt;/a&gt; from Hari Wiguna and modified it a little bit. Currently the implementation is not able the handle
 POST request or query parameters. At the moment only path segments are identified and separated.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;#include &amp;lt;SPI.h&amp;gt;
#include &amp;lt;Ethernet.h&amp;gt;

// Enter a MAC address and IP address for your controller below.
// The IP address will be dependent on your local network:
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
IPAddress ip(192,168,10, 177);

char cmd[15];
char param1[15];
boolean systemArmed = true;

#define STRING_BUFFER_SIZE 128
char buffer[STRING_BUFFER_SIZE];

EthernetServer server(80);

void setup() {
  Serial.begin(9600);
  // start the Ethernet connection and the server:
  Ethernet.begin(mac, ip);
  server.begin();
  Serial.print(&#34;server is at &#34;);
  Serial.println(Ethernet.localIP());
}

void send404(EthernetClient client) {
     client.println(&#34;HTTP/1.1 404 OK&#34;);
     client.println(&#34;Content-Type: text/html&#34;);
     client.println(&#34;Connnection: close&#34;);
     client.println();
     client.println(&#34;&amp;lt;!DOCTYPE HTML&amp;gt;&#34;);
     client.println(&#34;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;404&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#34;);
}

void sendStatus(EthernetClient client) {

   // Send a standard http response header
   client.println(&#34;HTTP/1.1 200 OK&#34;);
   client.println(&#34;Content-Type: application/json&#34;);
   client.println(&#34;Connnection: close&#34;);
   client.println();
   client.println(&#34;{&#34;);

   // Output the value of each analog input pin
   for (int analogChannel = 0; analogChannel &amp;lt; 6; analogChannel++) {
       int sensorReading = analogRead(analogChannel);
       client.print(&#34;\&#34;analog_in_&#34;);
       client.print(analogChannel);
       client.print(&#34;\&#34;: &#34;);
       client.print(sensorReading);

//       if (analogChannel != 5) {
           client.println(&#34;,&#34;);
//       }
   }
   client.print(&#34;\&#34;system_armed\&#34;: &#34;);
   client.print( systemArmed );
   client.println(&#34;\n}&#34;);
}

/**
 * Parse the string and return an array which contains all path segments
 */
char** parse(char* str) {

	char ** messages;
	messages = (char**)malloc(sizeof(char *));
	char *p;
	p = strtok(str, &#34; &#34;);
	unsigned int i = 0;
	while (p != NULL) {
	  p = strtok(NULL, &#34;/&#34;);
	  char *sp;
	  boolean last = false;
	  sp = strchr(p, &#39; &#39;);
	  if (sp != NULL) {
            *sp++ = &#39;\0&#39;;
	    last = true;
	  }
	  messages[i] = p;
	  i++;
	  if (last) {
	    break;
	  }
	  messages = (char**)realloc(messages, sizeof(char *) * i + 1);
	}

	messages[i] = &#39;\0&#39;;
	return messages;
}

void armSystem() {
  systemArmed = true;
}

void disarmSystem() {
  systemArmed = false;
}

void handleCommand(EthernetClient client, char* cmd, char* param) {
    if (strcmp(cmd, &#34;status&#34;) == 0) {
      Serial.println(&#34;status&#34;);
      sendStatus(client);
    } else if (strcmp(cmd, &#34;arm&#34;) == 0) {
      armSystem();
      sendStatus(client);
      Serial.println(&#34;arm&#34;);
    } else if (strcmp(cmd, &#34;disarm&#34;) == 0) {
      disarmSystem();
      sendStatus(client);
      Serial.println(&#34;disarm&#34;);
    } else {
      send404(client);
    }
}

int countSegments(char* str) {
  int p = 0;
  int count = 0;
  while (str[p] != &#39;\0&#39;) {
    if (str[p] == &#39;/&#39;) {
      count++;
    }
    p++;
  }
  // We don&#39;t want to count the / in &#39;HTTP/1.1&#39;
  count--;
  return count;
}

void loop() {
  // listen for incoming clients
  EthernetClient client = server.available();
  if (client) {
    // an http request ends with a blank line
    boolean currentLineIsBlank = true;
    while (client.connected()) {
      if (client.available()) {

        char c;
        int bufindex = 0; // reset buffer
        buffer[0] = client.read();
        buffer[1] = client.read();
        bufindex = 2;
        // Read the first line to determin the request page
        while (buffer[bufindex-2] != &#39;\r&#39; &amp;amp;&amp;amp; buffer[bufindex-1] != &#39;\n&#39;) {
            // read full row and save it in buffer
            c = client.read();
            if (bufindex&amp;lt;STRING_BUFFER_SIZE) {
              buffer[bufindex] = c;
            }
            bufindex++;
        }
        // Clean buffer for next row
        bufindex = 0;

        // Parse the query string
        int nSegments = countSegments(buffer);
        char **pathsegments = parse(buffer);

        int i = 0;
        for(i=0; i&amp;lt;nSegments; i++) {
          Serial.println(pathsegments[i]);
        }

        if (c == &#39;\n&#39; &amp;amp;&amp;amp; currentLineIsBlank) {
          handleCommand(client, pathsegments[0], pathsegments[1]);
          break;
        }

        if (c == &#39;\n&#39;) {
          currentLineIsBlank = true;
        } else if (c != &#39;\r&#39;) {
          currentLineIsBlank = false;
        }
      }
    }
    // Give the web browser time to receive the data
    delay(1);
    // Close the connection:
    client.stop();
    Serial.println(&#34;Client disonnected&#34;);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>