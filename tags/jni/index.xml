<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jni on Jotschi&#39;s Blog</title>
    <link>http://jotschi.de/tags/jni/</link>
    <description>Recent content in Jni on Jotschi&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Sep 2011 21:10:34 +0000</lastBuildDate>
    <atom:link href="http://jotschi.de/tags/jni/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JavaCPP Examples</title>
      <link>http://jotschi.de/2011/09/23/javacpp-examples/</link>
      <pubDate>Fri, 23 Sep 2011 21:10:34 +0000</pubDate>
      
      <guid>http://jotschi.de/2011/09/23/javacpp-examples/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I finally found the time to write post about the javacpp &amp;lt;a href=&#34;https://github.com/Jotschi/javacpp-examples&#34;&amp;gt;examples&amp;lt;/a&amp;gt; i created since i wanted to explore the capabilities of the &amp;lt;a href=&#34;http://code.google.com/p/javacpp/&#34;&amp;gt;JavaCPP library&amp;lt;/a&amp;gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;Please note that the examples are only tested under linux and probably won&amp;#8217;t run on windows/mac.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The examples can be fetched from my &lt;a href=&#34;https://github.com/Jotschi/javacpp-examples&#34;&gt;github repository&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;So far i created four different examples. Each for a specific usecase:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_javacpp_sharedlib_example&#34;&gt;javacpp-sharedlib-example&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This example shows how to use a own cpp shared library with the library.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The example consists of multiple pieces that finally work together.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;1. Cube.cpp&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The shared lib will be created from the Cube cpp class.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;#include &#34;Cube.h&#34;

void Cube::setSide(double s) {
	side = s &amp;lt;= 0 ? 1 : s;
}

double Cube::getSide() {
	return side;
}

double Cube::getArea() {
	return 6 * side * side;
}

double Cube::getVolume() {
	return side * side * side;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;Cube.h&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;#ifndef CUBE_H
#define CUBE_H

class Cube {
	private:
		double side;
	public:
		Cube() {};
		~Cube() {};

		// copy constructor
		Cube(class Cube&amp;amp; cube) {
			side = cube.side;
		}

		void setSide(double s);
		double getSide();
		double getArea();
		double getVolume();
};

#endif&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_2_javacube_java&#34;&gt;2. JavaCube.java&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The JavaCube java class acts as a wrapper/glue that fits between the gap of java and native code. Normally you would here defined your jni hooks which then would be implemented. Since i use JavaCPP this step is radically simplified. The annotations are used to give javacpp all the information it needs to prepare its g++ command that in the final compile step will create the library that can be shipped with the java program.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;package de.jotschi.javacpp.example;
import static com.googlecode.javacpp.Loader.load;

import com.googlecode.javacpp.Pointer;
import com.googlecode.javacpp.annotation.Name;
import com.googlecode.javacpp.annotation.Platform;

@Platform(include = &#34;Cube.h&#34;, link = &#34;Cube&#34;)
public class JavaCube {

	NativeCube cube;
	static {
		load();
	}

	public JavaCube() {
		cube = new NativeCube();
	}

	public void setSide(double s) {
		cube.setSide(s);

	}

	public double getArea() {
		return cube.getArea();
	}

	public double getSide() {
		return cube.getSide();
	}

	public double getVolume() {
		return cube.getVolume();
	}

	@Name(&#34;Cube&#34;)
	public static class NativeCube extends Pointer {

		static {
			load();
		}

		public NativeCube() {
			allocate();
		}

		public NativeCube(Pointer p) {
			super(p);
		}

		public native void setSide(double s);

		// this = new Cube()
		private native void allocate();

		private native double getArea();

		private native double getSide();

		private native double getVolume();

	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Once the java files have been compiled the exec-maven-plugin will be executed which itself executes the makefile that builds the shared library.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&amp;lt;execution&amp;gt;
	&amp;lt;id&amp;gt;build-sharedlib&amp;lt;/id&amp;gt;
	&amp;lt;phase&amp;gt;process-classes&amp;lt;/phase&amp;gt;
	&amp;lt;goals&amp;gt;
		&amp;lt;goal&amp;gt;exec&amp;lt;/goal&amp;gt;
	&amp;lt;/goals&amp;gt;
	&amp;lt;configuration&amp;gt;
		&amp;lt;executable&amp;gt;make&amp;lt;/executable&amp;gt;
		&amp;lt;commandlineArgs&amp;gt;main&amp;lt;/commandlineArgs&amp;gt;
		&amp;lt;workingDirectory&amp;gt;${basedir}/src/main/jni&amp;lt;/workingDirectory&amp;gt;
	&amp;lt;/configuration&amp;gt;
&amp;lt;/execution&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This library will be used within the next execution of the exec-maven-plugin. This final execution step will invoke the javacpp builder which generated the jni headers from the java class annotations and it also compiles the jni header interface against the previously created library.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&amp;lt;execution&amp;gt;
	&amp;lt;id&amp;gt;build-jnilib&amp;lt;/id&amp;gt;
	&amp;lt;phase&amp;gt;process-classes&amp;lt;/phase&amp;gt;
	&amp;lt;goals&amp;gt;
		&amp;lt;goal&amp;gt;exec&amp;lt;/goal&amp;gt;
	&amp;lt;/goals&amp;gt;
	&amp;lt;configuration&amp;gt;
		&amp;lt;executable&amp;gt;java&amp;lt;/executable&amp;gt;
		&amp;lt;commandlineArgs&amp;gt;-jar ../libs/javacpp.jar -Dcompiler.linkpath=${basedir}/target/classes/linux-x86 -Dcompiler.includepath=${basedir}/src/main/jni -classpath target/classes de.jotschi.javacpp.example.JavaCube&amp;lt;/commandlineArgs&amp;gt;
	&amp;lt;/configuration&amp;gt;
&amp;lt;/execution&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The CubeTest.java Junit tests shows how the created java class that wraps the native class works.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_javacpp_libc6_example_javacpp_stdlib_example&#34;&gt;javacpp-libc6-example / javacpp-stdlib-example&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;These examples are very similar to the javacpp-sharedlib-example. The libc6 example show how to use JavaCPP with the libc6 library and c code. The stdlib example on the other hand uses the c++ stdlib.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_javacpp_android_example&#34;&gt;javacpp-android-example&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This example shows how to use a android maven project in combination with JavaCPP. The example shows how to mix java with native code. The java part creates a opengl surface and the native code is used to execute a opengl function that changed the color of the display.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>