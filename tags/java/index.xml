<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Jotschi&#39;s Blog</title>
    <link>http://jotschi.de/tags/java/</link>
    <description>Recent content in Java on Jotschi&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 10 Jun 2015 18:00:00 +0000</lastBuildDate>
    <atom:link href="http://jotschi.de/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Graph Database Java OGM Comparison</title>
      <link>http://jotschi.de/2015/06/10/graphdb-ogm-comparison/</link>
      <pubDate>Wed, 10 Jun 2015 18:00:00 +0000</pubDate>
      
      <guid>http://jotschi.de/2015/06/10/graphdb-ogm-comparison/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I have been using graph databases for a while (mostly Neo4j) and i thought it might be a good idea to write down some of the things i noted while using &lt;a href=&#34;http://neo4j.com/&#34;&gt;Neo4j&lt;/a&gt; in combination with &lt;a href=&#34;http://projects.spring.io/spring-data-neo4j/&#34;&gt;Spring Data Neo4j (SDN)&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I also compiled a comparison of various graph databases a while ago. My list only includes Java based graph databases that allow embedding. I won&amp;#8217;t go into details about the feature sets and how those differ between each of those databases. Instead i just point out the most important aspects i noticed while using the OGM&amp;#8217;s and graph databases.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id=&#34;_graph_databases&#34; class=&#34;sect0&#34;&gt;Graph Databases&lt;/h1&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_neo4j&#34;&gt;Neo4j&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://neo4j.com/&#34;&gt;Neo4j&lt;/a&gt; was the first graph database i have ever used. It is &lt;a href=&#34;https://github.com/neo4j&#34;&gt;open source&lt;/a&gt; and very fast. It also ships directly with a neat little admin ui which can be used to visualize your graph data.
The database is very easy to embed and comes with a powerful query language (cypher). I don&amp;#8217;t know whether there are any other dedicated OGM/ORM layers for Neo4j besides of SDN and blueprint based OGMs.
The licensing on the other hand is not very useful once you decide to embed Neo4j in your application.
Neo4j Community Edition is licensed under GPL. MySQL is also licensed under GPL.
This means when you would not embed the database and only use the provided Neo4j REST API you would not need to license your application under GPL.
Once you embed the database in your application you must license your application under GPL. This gets even worse when you decide to utilize the clustering features. In this case you would need to license your application under AGPL (even if you would use Neo4j though the REST API)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The High Availability mode (Master/Slave Replication) can also be used when embedding the database. I wrote a &lt;a href=&#34;https://github.com/Jotschi/neo4j-ha-example&#34;&gt;dummy project&lt;/a&gt; a while ago that contains a working example.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_orientdb&#34;&gt;OrientDB&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://orientdb.com/&#34;&gt;OrientDB&lt;/a&gt; is also open source. There is no cypher but you can use Orient SQL. Embedding is also very easy and the licensing with Apache 2 license is very developer friendly. Tinkerpop support is very good.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The blueprint API is the nativ API for orientdb. This means no additional blueprint API implementation is needed when using a blueprint based OGM.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_sparsity_sparksee&#34;&gt;Sparsity Sparksee&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I have never used &#34;Sparsity Sparksee&#34;:http://www.sparsity-technologies.com/ but feature wise it is comparable to the other big graph databases.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_titan_db&#34;&gt;Titan DB&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://thinkaurelius.github.io/titan/&#34;&gt;Titan DB&lt;/a&gt; is an interesting database. The storage layer for this graph database is interchangeable. You can use &lt;a href=&#34;http://en.wikipedia.org/wiki/Berkeley_DB&#34;&gt;Berkeley DB&lt;/a&gt; which is quiet fast but it basically limits the size of nodes you can store and you can&amp;#8217;t use clustering.
Alternatively you can also use &lt;a href=&#34;http://cassandra.apache.org/&#34;&gt;Cassandra&lt;/a&gt;. Cassandra is slower compared to BerkeleyDB but it supports replication.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_hypergraphdb&#34;&gt;Hypergraphdb&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I have never used this database and can&amp;#8217;t say much about it but my impression is that it is very small and the feature set is limited.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;_performance_comparison&#34; class=&#34;sect0&#34;&gt;Performance comparison&lt;/h1&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The performance comparision is very superficial and you should keep in mind that the usecase for the database should always dictate the choice.
I have just compared low level read and write speed because i was interested in those. The benchmark does not cover any kind of graph traversals. I was merely interessted in the speed it takes each database to output a single node.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;All tests were executed within in a JVM that also excuted the graph database. I created 10k nodes and read those 10k nodes sequentially and in random order. No warmup phase was added.
As a baseline i choose Neo4j because it got the overall best performance. (less % is better)&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&#34;tableblock frame-all grid-all spread&#34;&gt;
&lt;colgroup&gt;
&lt;col style=&#34;width: 25%;&#34;&gt;
&lt;col style=&#34;width: 25%;&#34;&gt;
&lt;col style=&#34;width: 25%;&#34;&gt;
&lt;col style=&#34;width: 25%;&#34;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;DB&lt;/th&gt;
&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;write 10k&lt;/th&gt;
&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;read 10k seq&lt;/th&gt;
&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;read 10k random&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;Neo4j&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;100%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;100%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;100%&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;OrientDB&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;171%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;101%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;104%&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;Titan DB (Cassandra)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;314%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;502%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;510%&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;Titan DB (BerkeleyDB)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;-&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;200%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;205%&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;_ogm_object_graph_mapping&#34; class=&#34;sect0&#34;&gt;OGM - Object Graph Mapping&lt;/h1&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I created a &lt;a href=&#34;https://github.com/Jotschi/graph-ogm-examples&#34;&gt;github project&lt;/a&gt; that contains examples for all mentioned OGM&amp;#8217;s and graph databases.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_spring_data_neo4j&#34;&gt;Spring Data Neo4j&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I have used SDN a lot and i&amp;#8217;m quiet impressed by it. Getting started is quiet easy and there are a lot of examples out there.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;SDN uses annotations to map the entities and relationships. Inheritance of objects is directly mapped to the labels of a node. It is possible to create Spring Data Repositories that retrieve objects by using property values or by specifying cypher statements.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;What i like is the paging cypher support. What i do not like is the amount of classes and interfaces you need to create to interface with your objects but i guess this is always application specific.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;When mentioning SDN it is important to note the differences between the versions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_3_3_x&#34;&gt;3.3.x&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Jotschi/graph-ogm-examples/tree/master/spring-data-neo4j-3.x&#34;&gt;Example project&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Example usecase:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;User.java - Defines the entity&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UserRepository.java - Defines the SDN user repository&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UserRepositoryImpl.java - Defines a SDN repository implementation that may contain custom repository method implementations&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UserActions.java - Interface that contains the methods (is extended by UserRepository and implemented by UserRepositoryImpl)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UserService      - Defines methods that the implementation may use to manipulate user objects.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UserServiceImpl  - Implements the defined methods.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Another point that caused a lot of trouble for me was the @Fetch annotation. The getGroups() method would load the full entities (groups) when adding the @Fetch annotation to the method. This could cause to infinitive recursions or huge loading times. At the end i removed nearly all @Fetch annotations from my projects.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Instead i used the &lt;a href=&#34;http://docs.spring.io/autorepo/docs/spring-data-neo4j/current/api/org/springframework/data/neo4j/support/Neo4jTemplate.html&#34;&gt;Neo4jTemplate&lt;/a&gt; class in order to populate the returned enitity. When no @Fetch was specified only a shallow object with no properties is returned. Using the neo4jTemplate.fetch() this shallow object could be loaded.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Additionally SDN 3.x was/is slow as hell when using a remote Neo4j instead of the embedded one. This is another reason why SDN 4.x was developed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@NodeEntity
public class User extends AbstractPersistable {

	private String lastname;

	private String firstname;

	@Indexed(unique = true)
	private String username;

  @RelatedTo(type = &#34;MEMBER_OF&#34;, direction = Direction.OUTGOING, elementClass = Group.class)
	private Set&amp;lt;Group&amp;gt; groups = new HashSet&amp;lt;&amp;gt;();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_4_x&#34;&gt;4.x&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Jotschi/graph-ogm-examples/tree/master/spring-data-neo4j-4.x&#34;&gt;Example project&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;SDN 4.x is still in development and is currently not using the Neo4j Core API directly. Instead it relies on the Neo4j REST API. The overall performance for remote connected neo4j servers is faster (compared to SDN 3.3 in remote mode).
I can only guess why Neo4j/Pivotal Software choose this approach but my guess is that they started a rewrite of SDN in preparation for the binary protocol support for neo4j and to speedup SDN when using a remote Neo4j.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://docs.spring.io/spring-data/neo4j/docs/4.0.0.M1/reference/html/&#34;&gt;Documentation 4.0.0.M1&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_tinkerpop&#34;&gt;Tinkerpop&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://tinkerpop.incubator.apache.org/&#34;&gt;Tinkerpop&lt;/a&gt; is a collection of APIs that allow transparent and easy interfacing with graph databases. The blueprint API is the most low level api which is used to wrap the graph databases native API. By doing so it provides a standarized API which other APIs can use to interface with a graph db through this API layer. The API layer is very thin. There are various wrappers for many graph databases. I have used the &lt;a href=&#34;https://github.com/tinkerpop/blueprints/tree/master/blueprints-neo4j2-graph&#34;&gt;blueprint neo4j implementation&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Tinkerpop Blueprint is generally a good choice when you want to develop your application but you are not yet sure what graph database you will use at the end.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;There are three OGM&amp;#8217;s that are based upon the blueprint API i have looked at.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The &lt;a href=&#34;https://github.com/freemo/Ferma-benchmark&#34;&gt;Ferma Benchmark&lt;/a&gt; contains measurements for Frames, Totorom and Ferma.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_tinkerpop_2_frames&#34;&gt;Tinkerpop 2 - Frames&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Jotschi/graph-ogm-examples/tree/master/frames&#34;&gt;Example project&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The Frames API uses annotations similar to SDN and thus switching from SDN to Frames is not that hard. Indices have to be created separately. Tinkerpop does not support cypher. You would need to write your &lt;a href=&#34;http://sql2gremlin.com/&#34;&gt;statements in gremlin&lt;/a&gt; instead. The project seems not very active and Frames will not be part of Tinkerpop 3.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;public interface User extends AbstractPersistable {

        @Property(&#34;firstname&#34;)
        public String getFirstname();

        @Property(&#34;firstname&#34;)
        public void setFirstname(String name);

        @Property(&#34;lastname&#34;)
        public String getLastname();

        @Property(&#34;lastname&#34;)
        public void setLastname(String name);

        @Property(&#34;username&#34;)
        public String getUsername();

        @Property(&#34;username&#34;)
        public void setUsername(String name);

        @Adjacency(label = &#34;HAS_USER&#34;, direction = Direction.OUT)
        public Iterable&amp;lt;Group&amp;gt; getGroups();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_tinkerpop_totorom&#34;&gt;Tinkerpop - Totorom&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Jotschi/graph-ogm-examples/tree/master/totorom&#34;&gt;Example project&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I guess &lt;a href=&#34;https://github.com/BrynCooke/totorom&#34;&gt;Totorom&lt;/a&gt; could be seen as a successor to Frames. It is faster compared to Frames and it nativly interfaces with the tinkerpop gremlin query API.
The whole OGM is also very small. Many (all?) annotations are gone. Instead of interfaces you write classes which make things a lot easier compared to frames. In frames custom method handlers would need a special annotation (@JavaHandler) and a dedicated handler implementation for the method. With Totorom you just add your custom method.
Unfortunately the project itself is not very active (as for 06/2015).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;public class User extends AbstractPersistable {

        public static String FIRSTNAME_KEY = &#34;firstname&#34;;

        public static String LASTNAME_KEY = &#34;lastname&#34;;

        public static String USERNAME_KEY = &#34;username&#34;;

        public String getFirstname() {
                return getProperty(FIRSTNAME_KEY);
        }

        public void setFirstname(String name) {
                setProperty(FIRSTNAME_KEY, name);
        }

        public String getLastname() {
                return getProperty(LASTNAME_KEY);
        }

        public void setLastname(String name) {
                setProperty(LASTNAME_KEY, name);
        }

        public String getUsername() {
                return getProperty(USERNAME_KEY);
        }

        public void setUsername(String name) {
                setProperty(USERNAME_KEY, name);
        }

        public List&amp;lt;Group&amp;gt; getGroups() {
                return out(&#34;HAS_USER&#34;).toList(Group.class);
        }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_ferma&#34;&gt;Ferma&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&#34;Example projects&#34;:https://github.com/Jotschi/graph-ogm-examples/tree/master/ferma&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The API of &#34;Ferma&#34;:https://github.com/Syncleus/Ferma is very similar to Totorom. Ferma has various operation modes. It also supports the Frames annotations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;What i found useful:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ferma is exposing the raw graph API.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The project is active as of 06/2015&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&#34;http://wiki.syncleus.com/index.php/Ferma&#34;&gt;documentation&lt;/a&gt; is quite good.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The API contains useful method that can improve performance or prevent boilerplate code (e.g: toListExplicit, nextExplicit, nextOrDefault)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;public class User extends AbstractPersistable {

        public static String FIRSTNAME_KEY = &#34;firstname&#34;;

        public static String LASTNAME_KEY = &#34;lastname&#34;;

        public static String USERNAME_KEY = &#34;username&#34;;

        public String getFirstname() {
                return getProperty(FIRSTNAME_KEY);
        }

        public void setFirstname(String name) {
                setProperty(FIRSTNAME_KEY, name);
        }

        public String getLastname() {
                return getProperty(LASTNAME_KEY);
        }

        public void setLastname(String name) {
                setProperty(LASTNAME_KEY, name);
        }

        public String getUsername() {
                return getProperty(USERNAME_KEY);
        }

        public void setUsername(String name) {
                setProperty(USERNAME_KEY, name);
        }

        public List&amp;lt;Group&amp;gt; getGroups() {
                return out(&#34;HAS_USER&#34;).toList(Group.class);
        }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Minimal Google Docs Java Client</title>
      <link>http://jotschi.de/2009/12/06/minimal-google-docs-java-client/</link>
      <pubDate>Sun, 06 Dec 2009 23:45:12 +0000</pubDate>
      
      <guid>http://jotschi.de/2009/12/06/minimal-google-docs-java-client/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This code demonstrates how to fetch docs via google docs java api.
This example is usable with the &lt;a href=&#34;http://code.google.com/p/gdata-java-client/&#34;&gt;gdata-java-client&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;

import com.google.gdata.client.GoogleService;
import com.google.gdata.client.GoogleAuthTokenFactory.UserToken;
import com.google.gdata.client.docs.DocsService;
import com.google.gdata.data.MediaContent;
import com.google.gdata.data.media.MediaSource;

public class MinimalGoogleDocsClient {

	private static final String APPLICATION_NAME = &#34;JavaGDataClientSampleAppV3.0&#34;;
	public static final String SPREADSHEETS_SERVICE_NAME = &#34;wise&#34;;
	public DocsService service;
	public GoogleService spreadsheetsService;

	public void getSpreadSheet(String id) throws Exception {
		UserToken docsToken = (UserToken) service.getAuthTokenFactory()
				.getAuthToken();
		UserToken spreadsheetsToken = (UserToken) spreadsheetsService
				.getAuthTokenFactory().getAuthToken();
		service.setUserToken(spreadsheetsToken.getValue());

		URL url = new URL(
				&#34;http://spreadsheets.google.com/feeds/download/spreadsheets/Export?gid=0&amp;amp;exportFormat=csv&amp;amp;key=&#34;
						+ id);

		readUrl(url);
		service.setUserToken(docsToken.getValue());
	}

	public void getDocument(String id) throws Exception {
		URL url = new URL(
				&#34;http://docs.google.com/feeds/download/documents/Export?docID=document:&#34;
						+ id + &#34;&amp;amp;exportFormat=txt&#34;);
		readUrl(url);
	}

	public void readUrl(URL url) throws Exception {
		MediaContent mc = new MediaContent();
		mc.setUri(url.toString());
		MediaSource ms = service.getMedia(mc);

		BufferedReader in = new BufferedReader(new InputStreamReader(ms
				.getInputStream()));

		String inputLine;
		while ((inputLine = in.readLine()) != null) {
			System.out.println(inputLine);
		}

	}

	public void go() throws Exception {
		String user = &#34;YOURUSERNAME&#34;;
		String pass = &#34;YOURPASS&#34;;

		service = new DocsService(APPLICATION_NAME);
		spreadsheetsService = new GoogleService(SPREADSHEETS_SERVICE_NAME,
				APPLICATION_NAME);

		service.setUserCredentials(user, pass);
		spreadsheetsService.setUserCredentials(user, pass);

		getSpreadSheet(&#34;0ApGHrBnaasfKdDJSaUc0TSEzcmZXb0Z5MU9JN3ZuUXc&#34;);

		getDocument(&#34;0AZGHrBnasfsasKZGQ1OXdqbTafsasfWYydHE5OWRk&#34;);

	}

	public static void main(String[] args) throws Exception {

		new MinimalGoogleDocsClient().go();

	}

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Remote Monitoring Heap Memory Usage Using JMX RMI</title>
      <link>http://jotschi.de/2009/01/26/remote-monitoring-heap-memory-usage-using-jmx-rmi/</link>
      <pubDate>Mon, 26 Jan 2009 00:20:03 +0000</pubDate>
      
      <guid>http://jotschi.de/2009/01/26/remote-monitoring-heap-memory-usage-using-jmx-rmi/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Perhaps you want to record the memory usage of your application during runtime? Here is how to do it within java iself. Note that you won&amp;#8217;t have to add code to your target application.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;An example application that will be monitored using jmx/rmi:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;package org.schueth.dummytest;

import java.util.ArrayList;

public class DummyApp {

	/**
	 * @param args
	 */
	public static void main(String[] args) throws Exception {
		ArrayList&amp;lt;String&amp;gt; anyList = new ArrayList&amp;lt;String&amp;gt;();
		while (true) {
			Thread.sleep(100);
			anyList.add(random());
		}
	}

	public static String random() {
		StringBuffer s = new StringBuffer();
		int i = 0;
		while (i &amp;lt; 400) {
			s.append((char) (int) (Math.random() * 10 + 65));
			i++;
		}
		return s.toString();
	}

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The application that will read the MemoryMXBean information:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;package org.schueth.jmx;

import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import javax.management.MBeanServerConnection;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;

public class JMXTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) throws Exception {

		JMXServiceURL u = new JMXServiceURL(
				&#34;service:jmx:rmi:///jndi/rmi://localhost:9999/jmxrmi&#34;);
		JMXConnector c = JMXConnectorFactory.connect(u);
		MBeanServerConnection mbsc = c.getMBeanServerConnection();

		MemoryMXBean mbean = ManagementFactory.newPlatformMXBeanProxy(mbsc,
				ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);

		while (true) {
			System.out.println(mbean.getHeapMemoryUsage());
			System.out.println(mbean.getNonHeapMemoryUsage());
			Thread.sleep(100);
		}

	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;olist arabic&#34;&gt;
&lt;ol class=&#34;arabic&#34;&gt;
&lt;li&gt;
&lt;p&gt;Start the DummyApp with the folling params using at least java 1.5:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;java -D -Dcom.sun.management.jmxremote.authenticate=false  -Dcom.sun.management.jmxremote.port=9999  -Dcom.sun.management.jmxremote.ssl=false  -cp bin org.schueth.dummytest.DummyApp&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>AsynchronousBufferedInputStreamWrapper</title>
      <link>http://jotschi.de/2008/12/02/asynchronousbufferedinputstreamwrapper/</link>
      <pubDate>Tue, 02 Dec 2008 21:53:16 +0000</pubDate>
      
      <guid>http://jotschi.de/2008/12/02/asynchronousbufferedinputstreamwrapper/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Some time ago i was looking for a nice and quiet fast implementation for a buffered inputstream. I found some pieces and finally i came up with this one.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Just create a new AsynchronousBufferedInputStreamWrapper by using your unbuffered InputStream and the buffersize of your choice (eg. 512*256)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Invoke startBuffering() to start the buffering.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;getBufferLevel() will return the current level of the buffer in percent of maximum.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This implementation is untested but it might be useful for someone. Please note also that you might have to change my logger implementation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;

import org.apache.log4j.Logger;
import org.schueth.snplayer.utils.SimpleLogger;

public class AsynchronousBufferedInputStreamWrapper extends InputStream {

	Thread thread;
	BufferingThread buffering;
	Logger logger = SimpleLogger.getLogger();

	public AsynchronousBufferedInputStreamWrapper(InputStream inputStream,
			int bufferSizeInBytes) {

		buffering = new BufferingThread(this, new BufferedInputStream(
				inputStream, bufferSizeInBytes), bufferSizeInBytes);
	}

	public float getBufferLevel() {
		return buffering.getBufferLevel();
	}

	public void startBuffering() {
		logger.debug(&#34;Buffering started&#34;);
		thread = new Thread(buffering);
		thread.start();
	}

	@Override
	public int read() throws IOException {

		if (this.thread == null) {
			logger.info(&#34;MANUAL OVERRIDE!&#34;);
			startBuffering();
		}
		waitForCurrentByteBuffer();
		if (reachedEndOfStream()) {
			return -1;
		}

		byte b = buffering.currentByteBuffer[buffering.currentBufferPosition];
		buffering.currentBufferPosition++;
		buffering.overallBytesConsumed++;
		return b &amp;amp; 0xFF;
	}

	private boolean reachedEndOfStream() {
		return buffering.overallBytesConsumed == buffering.overallBytesBuffered;
	}

	private void waitForCurrentByteBuffer() {
		if (buffering.currentByteBuffer == null
				|| buffering.currentBufferPosition &amp;gt; buffering.currentByteBuffer.length - 1) {
			buffering.currentByteBuffer = null;
			while (buffering.currentByteBuffer == null &amp;amp;&amp;amp; !reachedEndOfStream()) {
				// System.out.println(&#34;Getting Queue element&#34;);
				buffering.currentByteBuffer = buffering.dataQueue.poll();
				buffering.currentBufferPosition = 0;
				try {
					TimeUnit.MILLISECONDS.sleep(5L);
				} catch (InterruptedException e) {
					logger.error(e);
				}
			}
		}
	}

	@Override
	public void close() throws IOException {
		super.close();
		this.thread.stop();
	}
}

class BufferingThread implements Runnable {

	AsynchronousBufferedInputStreamWrapper reference;
	Logger logger = SimpleLogger.getLogger();

	public static final int DEFAULT_BUFFER_SEGMENTSIZE = 128 * 1024;
	volatile boolean eof = false;

	volatile BufferedInputStream wrappedInputStream;
	volatile ConcurrentLinkedQueue&amp;lt;byte[]&amp;gt; dataQueue;
	int maxDataQueueSize;
	volatile int overallBytesConsumed = 0;
	int currentBufferPosition;

	volatile int totalBufferSizeInBytes;
	volatile int bufferSizeInBytes;
	volatile int overallBytesBuffered;
	int lastCurrentBytesBuffered;
	int currentBytesBuffered;
	byte[] currentByteBuffer;

	public BufferingThread(AsynchronousBufferedInputStreamWrapper reference,
			BufferedInputStream wrappedInputStream, int totalBufferSizeInBytes) {

		this.reference = reference;
		this.wrappedInputStream = wrappedInputStream;
		this.dataQueue = new ConcurrentLinkedQueue&amp;lt;byte[]&amp;gt;();

		this.totalBufferSizeInBytes = totalBufferSizeInBytes;
		this.maxDataQueueSize = totalBufferSizeInBytes
				/ DEFAULT_BUFFER_SEGMENTSIZE;
		this.bufferSizeInBytes = DEFAULT_BUFFER_SEGMENTSIZE;

		logger.info(&#34;totalBufferSizeInBytes: &#34; + totalBufferSizeInBytes);
		logger.info(&#34;maxDataQueueSize: &#34; + maxDataQueueSize);
		logger.info(&#34;bufferSizeInBytes: &#34; + bufferSizeInBytes);

	}

	public float getBufferLevel() {
		logger.debug(&#34;overallBytesBuffered: &#34; + overallBytesBuffered);
		logger.debug(&#34;overallBytesConsumed: &#34; + overallBytesConsumed);
		logger.debug(&#34;dataQueue.size(): &#34; + dataQueue.size());
		logger.debug(&#34;totalBufferSizeInBytes: &#34; + totalBufferSizeInBytes);
		if (overallBytesBuffered == 0 || (overallBytesBuffered==overallBytesConsumed)) {
			return 0;
		}

		return (((float)overallBytesConsumed / (float)overallBytesBuffered)-1 )*-1;

	}

	public void run() {

		currentBytesBuffered = overallBytesBuffered - overallBytesConsumed;

		while (!eof) {

			try {

				// check if buffer is not full
				if (dataQueue.size() &amp;lt; maxDataQueueSize) {

					// System.out.println(&#34;Buffering...&#34;);
					ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();

					// check if buffer is not full
					while (currentBytesBuffered &amp;lt; bufferSizeInBytes) {
						byte[] buffer = new byte[bufferSizeInBytes];
						int bytesRead = wrappedInputStream.read(buffer);

						if (bytesRead == -1) {
							// EOF
							logger.error(&#34;EOF&#34;);
							wrappedInputStream.close();
							eof = true;
							break;
						}

						// writing bytes to os
						byteArrayOutputStream.write(buffer, 0, bytesRead);
						overallBytesBuffered += bytesRead;

						currentBytesBuffered = overallBytesBuffered
								- overallBytesConsumed;

					}

					if (!eof) {
						// Adding byte array to queue
						dataQueue.add(byteArrayOutputStream.toByteArray());
						currentBytesBuffered = 0;
					}

				} else {
					TimeUnit.MILLISECONDS.sleep(4L);
				}
			} catch (Exception e) {
				logger.error(e);
			}
		}

		logger.info(&#34;Finished Buffering&#34;);
	}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>