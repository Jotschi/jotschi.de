<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Glsl on Jotschi&#39;s Blog</title>
    <link>http://jotschi.de/tags/glsl/</link>
    <description>Recent content in Glsl on Jotschi&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 08 Oct 2009 22:00:39 +0000</lastBuildDate>
    <atom:link href="http://jotschi.de/tags/glsl/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Texture Array Example And Clamp to Border Ati Issue Example</title>
      <link>http://jotschi.de/2009/10/08/texture-array-example-and-clamp-to-border-ati-issue-example/</link>
      <pubDate>Thu, 08 Oct 2009 22:00:39 +0000</pubDate>
      
      <guid>http://jotschi.de/2009/10/08/texture-array-example-and-clamp-to-border-ati-issue-example/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;This example covers the usage of texture arrays within opengl.
Although the main purpose of this example is to show that ati cards do not support CLAMP_TO_BORDER when using TEXTURE_2D_ARRAY&amp;#8217;s it might also be interesting for someone who want&amp;#8217;s to know how to set a texture uniform (sampler2d) or (sampler2darray).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The specification for texture arrays can be found here: &lt;a href=&#34;http://developer.download.nvidia.com/opengl/specs/GL_EXT_texture_array.txt&#34; class=&#34;bare&#34;&gt;http://developer.download.nvidia.com/opengl/specs/GL_EXT_texture_array.txt&lt;/a&gt;
This extension is also supported by the newest ati cards.
Screenshots were taken by using the example with an ati 4850 card and the latest drivers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;Update - Note:&lt;/em&gt;
Compile with:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;---
g++ -Wall -lglut -lGL -lGLUW -o ExampleProg Simple_ATI_TEXTURE_2D_ARRAY_Example.cpp
----
Get sources and libs:&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;apt-get install libglut3 libglut3-dev libglew1.5 libglew1.5-dev&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;Update:&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I just developed an workaround for this issue by adding clamp to border by myself to the shader:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;#extension GL_EXT_gpu_shader4 : enable

uniform sampler2DArray base_texture;
varying vec2 texCoord;
void main()
{

		vec4 borderColor =vec4(0.1,0.7,0.2,0.1);
		if(texCoord.s&amp;lt;1 &amp;amp;&amp;amp; texCoord.s &amp;gt;0 &amp;amp;&amp;amp; texCoord.t &amp;lt;1 &amp;amp;&amp;amp; texCoord.t &amp;gt;0)
		{
			borderColor		= texture2DArray(base_texture, vec3(texCoord.st,1));
		}
		gl_FragColor = borderColor;

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;NOARRAY - not definied&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The example will use GL_TEXTURE_2D_ARRAY as source for texturing and a fragment shader that defines a sampler2DArray uniform:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;span class=&#34;image&#34;&gt;&lt;img src=&#34;http://jotschi.de/images/opengl/GL_TEXTURE_2D_ARRAY_CLAMP_TO_BORDER-ATI.png&#34; alt=&#34;GL TEXTURE 2D ARRAY CLAMP TO BORDER ATI&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The texture is not clamped to the border even if the CLAMP_TO_BORDER attribute has been set.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;NOARRAY - definied&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;The example will use GL_TEXTURE_2D as source for texturing and a fragment shader that defines a sampler2D uniform:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;span class=&#34;image&#34;&gt;&lt;img src=&#34;http://jotschi.de/images/opengl/GL_TEXTURE_2D_CLAMP_TO_BORDER-ATI.png&#34; alt=&#34;GL TEXTURE 2D CLAMP TO BORDER ATI&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;As you can see clamp to border works like a charm. I changed the border color to make the clamp effect clearly visible:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Download the complete example sources: &lt;a href=&#34;http://jotschi.de/downloads/opengl/opengl_texture_array_glsl_example.tgz&#34;&gt;opengl_texture_array_glsl_example.tgz&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;shader_array.frag:&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;uniform sampler2DArray base_texture;
varying vec2 texCoord;
void main()
{
		vec4 color = vec4(1.0,0.5,0.2,0.1);
		vec4 base_color		= texture2DArray(base_texture, vec3(texCoord.st*vec2(0.5,1.5), 0));
		gl_FragColor = color * base_color;

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;shader_simple.frag:&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;uniform sampler2D base_texture;
varying vec2 texCoord;
void main()
{
		vec4 color = vec4(1.0,0.5,0.2,0.1);
		//vec2 texCoord = vec2(1.0,0.5);
		vec4 base_color = texture2D(base_texture, texCoord);
		gl_FragColor = color * base_color;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;shader.vert:&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;varying vec2 texCoord;
void main()
{
    texCoord = vec2(gl_MultiTexCoord0);
	gl_Position = ftransform();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;Simple_ATI_TEXTURE_2D_ARRAY_Example.cpp:&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;#include &amp;lt;GL/glew.h&amp;gt;
#include &amp;lt;GL/gl.h&amp;gt;
#include &amp;lt;GL/glut.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &#34;textfile.h&#34;

#define NOARRAY

#define	checkImageWidth 64
#define	checkImageHeight 64
static GLubyte checkImage[checkImageHeight][checkImageWidth][4];

char *VertexShaderSource, *FragmentShaderSource;

int VertexShader, FragmentShader;

int ShaderProgram;

GLfloat angle = 0.0;

GLuint texture;

void makeCheckImage(void) {
	int i, j, c;

	for (i = 0; i &amp;lt; checkImageHeight; i++) {
		for (j = 0; j &amp;lt; checkImageWidth; j++) {
			c = ((((i &amp;amp; 0x8) == 0) ^ ((j &amp;amp; 0x8)) == 0)) * 255;
			checkImage[i][j][0] = (GLubyte) c;
			checkImage[i][j][1] = (GLubyte) c;
			checkImage[i][j][2] = (GLubyte) c;
			checkImage[i][j][3] = (GLubyte) 255;
		}
	}
}

GLuint LoadTexture() {
	GLuint texture;
	makeCheckImage();
	glGenTextures(1, &amp;amp;texture);

	GLfloat borderColor[4] = { 1.0, 1.0, 1.0, 1.0 };
#ifdef NOARRAY
	glBindTexture(GL_TEXTURE_2D, texture);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, checkImageWidth, checkImageHeight,
			0, GL_RGBA, GL_UNSIGNED_BYTE, checkImage);
#else
	glBindTexture(GL_TEXTURE_2D_ARRAY_EXT, texture);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glTexParameterf(GL_TEXTURE_2D_ARRAY_EXT, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D_ARRAY_EXT, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D_ARRAY_EXT, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
	glTexParameterf(GL_TEXTURE_2D_ARRAY_EXT, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
	glTexParameterfv(GL_TEXTURE_2D_ARRAY_EXT, GL_TEXTURE_BORDER_COLOR, borderColor);

	glTexImage3D(GL_TEXTURE_2D_ARRAY_EXT, 0, GL_RGBA, checkImageWidth,
			checkImageHeight, 2, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
	glTexSubImage3D(GL_TEXTURE_2D_ARRAY_EXT, 0, 0, 0, 0, checkImageWidth,
			checkImageHeight, 1, GL_RGBA, GL_UNSIGNED_BYTE, checkImage);
	glTexSubImage3D(GL_TEXTURE_2D_ARRAY_EXT, 0, 0, 0, 1, checkImageWidth,
			checkImageHeight, 1, GL_RGBA, GL_UNSIGNED_BYTE, checkImage);

#endif

	return texture;
}

void FreeTexture(GLuint texture) {
	glDeleteTextures(1, &amp;amp;texture);
}

void Lighting(void) {
	GLfloat LightPosition[] = { 0.0, 0.0, 5.0, 1.0 };

	GLfloat DiffuseLight[] = { 1.0, 0.0, 0.0 };
	GLfloat AmbientLight[] = { 1.0, 1.0, 1.0 };
	GLfloat SpecularLight[] = { 1.0, 1.0, 1.0 };

	glLightfv(GL_LIGHT0, GL_SPECULAR, SpecularLight);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, DiffuseLight);
	glLightfv(GL_LIGHT0, GL_AMBIENT, AmbientLight);
	glLightfv(GL_LIGHT0, GL_POSITION, LightPosition);

	GLfloat mShininess[] = { 8 };

	GLfloat DiffuseMaterial[] = { 1.0, 0.0, 0.0 };
	GLfloat AmbientMaterial[] = { 0.3, 0.3, 0.3 };
	GLfloat SpecularMaterial[] = { 1.0, 1.0, 1.0 };

	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, DiffuseMaterial);
	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, AmbientMaterial);
	glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, SpecularMaterial);
	glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mShininess);
}

void display(void) {
	glClearColor(0.0, 0.0, 0.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();
	Lighting();
	glTranslatef(0, 0, -5);
	glRotatef(angle, 1, 1, 1);
	glRotatef(angle, 0, 1, 1);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, texture);
	int texture_location = glGetUniformLocationARB(ShaderProgram,
			&#34;base_texture&#34;);
	if (texture_location == -1) {
		printf(&#34;Notfound\n&#34;);
	}
	glUniform1iARB(texture_location, 0);

	// Disabled glsl fallback
	//glEnable(GL_TEXTURE_2D);

	glBegin(GL_QUADS);
	glTexCoord2f(0.0, 0.0);
	glVertex3f(-2.0, -1.0, 0.0);
	glTexCoord2f(0.0, 3.0);
	glVertex3f(-2.0, 1.0, 0.0);
	glTexCoord2f(3.0, 3.0);
	glVertex3f(0.0, 1.0, 0.0);
	glTexCoord2f(3.0, 0.0);
	glVertex3f(0.0, -1.0, 0.0);

	glTexCoord2f(0.0, 0.0);
	glVertex3f(1.0, -1.0, 0.0);
	glTexCoord2f(0.0, 3.0);
	glVertex3f(1.0, 1.0, 0.0);
	glTexCoord2f(3.0, 3.0);
	glVertex3f(2.41421, 1.0, -1.41421);
	glTexCoord2f(3.0, 0.0);
	glVertex3f(2.41421, -1.0, -1.41421);
	glEnd();
	glFlush();

	glutSolidTeapot(1);
	glutSwapBuffers();
	//angle += 0.5;
}

void InitShader(void) {

	VertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
	FragmentShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
	VertexShaderSource = textFileRead(&#34;shader.vert&#34;);
#ifdef NOARRAY
	FragmentShaderSource = textFileRead(&#34;shader_simple.frag&#34;);
#else
	FragmentShaderSource = textFileRead(&#34;shader_array.frag&#34;);
#endif

	const char * VS = VertexShaderSource;
	const char * FS = FragmentShaderSource;

	glShaderSourceARB(VertexShader, 1, &amp;amp;VS, NULL);
	glShaderSourceARB(FragmentShader, 1, &amp;amp;FS, NULL);

	glCompileShaderARB(VertexShader);
	glCompileShaderARB(FragmentShader);

	ShaderProgram = glCreateProgramObjectARB();

	glAttachObjectARB(ShaderProgram, VertexShader);
	glAttachObjectARB(ShaderProgram, FragmentShader);

	glLinkProgramARB(ShaderProgram);
	glUseProgramObjectARB(ShaderProgram);
}

void DeInitShader(void) {
	glDetachObjectARB(ShaderProgram, VertexShader);
	glDetachObjectARB(ShaderProgram, FragmentShader);

	glDeleteObjectARB(ShaderProgram);
}

void Init(void) {
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LEQUAL);

	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);

	texture = LoadTexture();
}

void reshape(int w, int h) {
	glViewport(0, 0, (GLsizei) w, (GLsizei) h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(60, (GLfloat) w / (GLfloat) h, 0.1, 1000.0);
	glMatrixMode(GL_MODELVIEW);
}

int main(int argc, char **argv) {
	glutInit(&amp;amp;argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(100, 100);
	glutCreateWindow(&#34;Ati texture array clamp issue example&#34;);
	glewInit();
	InitShader();
	Init();
	glutDisplayFunc(display);
	glutIdleFunc(display);
	glutReshapeFunc(reshape);
	glutMainLoop();
	DeInitShader();
	return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;textfile.cpp:&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;malloc.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;


char *textFileRead(char *fn) {


	FILE *fp;
	char *content = NULL;

	int f,count;
	f = open(fn, O_RDONLY);

	count = lseek(f, 0, SEEK_END);

	close(f);

	if (fn != NULL) {
		fp = fopen(fn,&#34;rt&#34;);

		if (fp != NULL) {


			if (count &amp;gt; 0) {
				content = (char *)malloc(sizeof(char) * (count+1));
				count = fread(content,sizeof(char),count,fp);
				content[count] = &#39;\0&#39;;
			}
			fclose(fp);
		}
	}
	return content;
}

int textFileWrite(char *fn, char *s) {

	FILE *fp;
	int status = 0;

	if (fn != NULL) {
		fp = fopen(fn,&#34;w&#34;);

		if (fp != NULL) {

			if (fwrite(s,sizeof(char),strlen(s),fp) == strlen(s))
				status = 1;
			fclose(fp);
		}
	}
	return(status);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;textfile.h:&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;char *textFileRead(char *fn);
int textFileWrite(char *fn, char *s);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>GLSL shader to handle multiple projections onto the same surface</title>
      <link>http://jotschi.de/2009/08/17/glsl-shader-to-handle-multiple-projections-onto-the-same-surface/</link>
      <pubDate>Mon, 17 Aug 2009 23:20:56 +0000</pubDate>
      
      <guid>http://jotschi.de/2009/08/17/glsl-shader-to-handle-multiple-projections-onto-the-same-surface/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;For my project &amp;lt;a href=&#34;http://www.jotschi.de/?page_id=320&#34;&amp;gt;Generating City Models By Using Panorama Images&amp;lt;/a&amp;gt; i have to write a fragment shader that handles multiple projections onto the same surface. The shader must contain condition in which the projection should be handled. In my case i had to decide which projection source should be used to texture the desired model. &amp;lt;a id=&#34;more&#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a id=&#34;more-363&#34;&amp;gt;&amp;lt;/a&amp;gt;
I didn&amp;#8217;t want to do alpha blending of each texture. I wanted that only the projection source will be used that would produce the best projection image. For a good projection the angle of which the projection &#39;light&#39; falls onto the surface must be very low. The second parameter is the distance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;For example, imagine a scene with 20 projection sources. One source is very near the target surface but the angle in which the &#39;light&#39; falls onto the surface is very big so the texture produced by such a source wouldn&amp;#8217;t be that good. Instead there is another projection source which&amp;#8217;s projections angle is very low but the distance is larger than that of the near source. My shader will now pick the second projection source because the first does not match its condtions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Draft of my target shader:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;uniform int nTextures;
uniform sampler2DArray textures;
uniform vec3[] projectPos;
varying vec3 glPos;
varying vec3 normalVec;
void main() {
  int currentTexture=0;
  float minAngle = 360.0f;
  float angleThreshold = 10.0f;
 // Select the texture with the lowest angle
  for(int i =0; i &amp;lt;nTextures; i++){
   float alpha = texture2DArray(textures,vec3(gl_TexCoord[0].xy, i)).a;
   if(alpha != 1.0f) {
     //TODO check calculation of projDirection
      vec3 projDirection =(projectPos-glPos);
      float angle = dot(normalVec,projDirection*-1);
      if(angle&amp;lt;minAngle) {
          minAngle = angle;
      }
    }
  }
  float minDistance= -1.0f;
  // Select the texture with the lowest distance among those around the lowest angle
  for(i=0; i &amp;lt;nTextures; i++){
   float alpha = texture2DArray(textures,vec3(gl_TexCoord[0].xy, i)).a;
   // Condition 1: Must be visible
   if (alpha != 1.0f) {
     //TODO check calculation of projDirection
     vec3 projDirection =( projectPos-glPos);
     float angle = dot(normalVec,projDirection);
     // Condition 2: The angle must be between +-10.0f of the lowest angle
     if(angle&amp;lt;(minAngle+angleThreshold) || angle&amp;gt;(minAngle+angleThreshold)) {
     // TODO check calculation of distance between both points within RÂ³
    float dx = projectPos[i].x - glPos.x;
  float dy = projectPos[i].y - glPos.y;
  float dz = projectPos[i].z - glPos.z;
  float d = Math.sqrt(dx * dx + dy * dy + dz * dz);
    // select the texture with the lowest distance
    if(d&amp;lt;minDistance || minDistance  ==-1.0f)  {
          minDistance = d;
          currentTexture = i;
    }
        }
   }
  }
gl_FragColor = texture2DArray(textures,vec3(gl_TexCoord[0].xy, currentTexture));
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;olist arabic&#34;&gt;
&lt;ol class=&#34;arabic&#34;&gt;
&lt;li&gt;
&lt;p&gt;Maybe there is a better way to check if the given sample contains a texture value at the given texture coordinate than checking its alpha value.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I use a uniform to handle the size of the sampler2DArray textures array. Maybe you can extract that information within the shader&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I use uniform vec3[] projectPos; to handle over the positions of the projection sources. Maybe this can be stored in the build in gl_LightSource array?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Projective Textures with OpenSceneGraph</title>
      <link>http://jotschi.de/2009/05/31/projective-textures-with-openscenegraph/</link>
      <pubDate>Sun, 31 May 2009 21:55:15 +0000</pubDate>
      
      <guid>http://jotschi.de/2009/05/31/projective-textures-with-openscenegraph/</guid>
      <description>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;I finally managed to get projective textures working using GLSL shaders rather than fixed pipeline functionality.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;span class=&#34;image&#34;&gt;&lt;img src=&#34;http://jotschi.de/images/osg/projection_fixedfunctionality.jpg&#34; alt=&#34;projection fixedfunctionality&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;osg/Notify&amp;gt;
#include &amp;lt;osg/MatrixTransform&amp;gt;
#include &amp;lt;osg/ShapeDrawable&amp;gt;
#include &amp;lt;osg/PositionAttitudeTransform&amp;gt;
#include &amp;lt;osg/Geometry&amp;gt;
#include &amp;lt;osg/Texture2D&amp;gt;
#include &amp;lt;osg/Geode&amp;gt;
#include &amp;lt;osg/LightSource&amp;gt;
#include &amp;lt;osg/TexGenNode&amp;gt;
#include &amp;lt;osg/TexMat&amp;gt;
#include &amp;lt;osgDB/WriteFile&amp;gt;
#include &amp;lt;osgUtil/Optimizer&amp;gt;
#include &amp;lt;osgDB/Registry&amp;gt;
#include &amp;lt;osgDB/ReadFile&amp;gt;
#include &amp;lt;osgViewer/Viewer&amp;gt;

osg::StateSet* createProjectorState() {

	osg::StateSet* stateset = new osg::StateSet;

	/* 1. Load the texture that will be projected */
	osg::Texture2D* texture = new osg::Texture2D();
	texture-&amp;gt;setImage(osgDB::readImageFile(&#34;foo.jpg&#34;));
	texture-&amp;gt;setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_BORDER);
	texture-&amp;gt;setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_BORDER);
	texture-&amp;gt;setWrap(osg::Texture::WRAP_R, osg::Texture::CLAMP_TO_BORDER);
	stateset-&amp;gt;setTextureAttributeAndModes(1, texture, osg::StateAttribute::ON);

	// set up tex gens
	stateset-&amp;gt;setTextureMode(1, GL_TEXTURE_GEN_S,
	osg::StateAttribute::ON);
	stateset-&amp;gt;setTextureMode(1, GL_TEXTURE_GEN_T,
	osg::StateAttribute::ON);
	stateset-&amp;gt;setTextureMode(1, GL_TEXTURE_GEN_R,
	osg::StateAttribute::ON);
	stateset-&amp;gt;setTextureMode(1, GL_TEXTURE_GEN_Q,
	osg::StateAttribute::ON);

	/* 2. Load the Shaders */
	osg::ref_ptr&amp;lt;osg::Program&amp;gt; projProg(new osg::Program);
	osg::ref_ptr&amp;lt;osg::Shader&amp;gt; projvertexShader(osg::Shader::readShaderFile(
			osg::Shader::VERTEX, &#34;VertexShader.glsl&#34;));
	osg::ref_ptr&amp;lt;osg::Shader&amp;gt; projfragShader(osg::Shader::readShaderFile(
			osg::Shader::FRAGMENT, &#34;FragmentShader.glsl&#34;));
	projProg-&amp;gt;addShader(projvertexShader.get());
	projProg-&amp;gt;addShader(projfragShader.get());

	/* 3. Handover the texture to the fragment shader via uniform */
	osg::Uniform* texUniform = new osg::Uniform(osg::Uniform::SAMPLER_2D,
			&#34;projectionMap&#34;);
	texUniform-&amp;gt;set(1);
	stateset-&amp;gt;addUniform(texUniform);

	/* 4. set Texture matrix*/
	osg::TexMat* texMat = new osg::TexMat;
	osg::Matrix mat;
	osg::Vec3 projectorPos = osg::Vec3(0.0f, 0.0f, 324.0f);
	osg::Vec3 projectorDirection = osg::Vec3(osg::inDegrees(0.0f),
			osg::inDegrees(280.0f), osg::inDegrees(-460.0f));
	float projectorAngle = 110;
	osg::Vec3 up(0.0f, 0.0f, 1.0f);
	mat = osg::Matrixd::lookAt(projectorPos, projectorPos + projectorDirection,
			up) * osg::Matrixd::perspective(projectorAngle, 1.0, 0.1, 100);
	texMat-&amp;gt;setMatrix(mat);
	stateset-&amp;gt;setTextureAttributeAndModes(1, texMat, osg::StateAttribute::ON);

	stateset-&amp;gt;setAttribute(projProg.get());
	return stateset;
}
osg::Node* createModel() {
	osg::Group* root = new osg::Group;

	/* Load the terrain which will be the receiver of out projection */
	osg::Node* terr = osgDB::readNodeFile(&#34;Terrain2.3ds&#34;);
	osg::Image* shot = new osg::Image();

	/* Scale the terrain and move it. */
	osg::Matrix m;
	osg::ref_ptr&amp;lt;osg::MatrixTransform&amp;gt; mt = new osg::MatrixTransform;
	m.makeTranslate(112.f, 410.f, -2.f);
	m.makeScale(2.f, 2.f, 2.f);
	mt-&amp;gt;setMatrix(m);
	mt-&amp;gt;addChild(terr);

	/* Add the transformed node to our graph */
	root-&amp;gt;addChild(mt.get());

	/* Enable projective texturing for all objects of this node */
	root-&amp;gt;setStateSet(createProjectorState());
	return root;
}
int main(int, char **) {
	osgViewer::Viewer viewer;
	viewer.setSceneData(createModel());
	viewer.setUpViewInWindow(0, 0, 1024, 768);
	return viewer.run();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;Fragment Shader&lt;/em&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;uniform sampler2D projectionMap;
varying vec4 projCoord;
void main()
{
	vec4 dividedCoord = projCoord / projCoord.w ;
	vec4 color =  texture2D(projectionMap,dividedCoord.st);
  	gl_FragColor =	 color * gl_Color;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;em&gt;Vertex Shader&lt;/em&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;varying vec4 projCoord;
void main()
{
     	projCoord = gl_TextureMatrix[1] * gl_Vertex;
		gl_Position = ftransform();
		gl_FrontColor = gl_Color;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>