--- 
layout: post
status: publish
published: true
title: JavaCPP Examples
author: Jotschi
author_login: admin
author_email: webmaster@jotschi.de
author_url: http://www.Jotschi.de
excerpt: |
  I finally found the time to write post about the javacpp <a href="https://github.com/Jotschi/javacpp-examples">examples</a> i created since i wanted to explore the capabilities of the <a href="http://code.google.com/p/javacpp/">JavaCPP library</a>.

wordpress_id: 645
wordpress_url: /?p=645
date: 2011-09-23 21:10:34 +00:00
categories: 
- Neuronensturm
- Technik
tags: 
- javacpp
- jni
- android
comments: 
- id: 5779
  author: fer
  author_email: fer.cisneros.e@gmail.com
  author_url: ""
  date: 2012-04-25 20:04:39 +0000
  date_gmt: 2012-04-25 18:04:39 +0000
  content: Is it possible to pass/return string arrays to c++ functions using javacpp ?
---
I finally found the time to write post about the javacpp <a href="https://github.com/Jotschi/javacpp-examples">examples</a> i created since i wanted to explore the capabilities of the <a href="http://code.google.com/p/javacpp/">JavaCPP library</a>.
<a id="more"></a><a id="more-645"></a>
<em>Please note that the examples are only tested under linux and probably won't run on windows/mac.</em>
The examples can be fetched from my <a href="https://github.com/Jotschi/javacpp-examples">github repository</a>.
<br/>

So far i created four different examples. Each for a specific usecase:
<h1>javacpp-sharedlib-example</h1>
This example shows how to use a own cpp shared library with the library. 


The example consists of multiple pieces that finally work together.

<h3>1. Cube.cpp</h3>
The shared lib will be created from the Cube cpp class.

<pre class="syntax c">
#include "Cube.h"

void Cube::setSide(double s) {
	side = s <= 0 ? 1 : s;
}

double Cube::getSide() {
	return side;
}

double Cube::getArea() {
	return 6 * side * side;
}

double Cube::getVolume() {
	return side * side * side;
}
</pre>

<h3>Cube.h</h3>
{% raw %}
<pre class="syntax c">
#ifndef CUBE_H
#define CUBE_H

class Cube {
	private:
		double side;
	public:
		Cube() {};
		~Cube() {};

		// copy constructor
		Cube(class Cube& cube) {
			side = cube.side;
		}

		void setSide(double s);
		double getSide();
		double getArea();
		double getVolume();
};

#endif
</pre>
{% endraw %}

<h3>2. JavaCube.java</h3> 
The JavaCube java class acts as a wrapper/glue that fits between the gap of java and native code. Normally you would here defined your jni hooks which then would be implemented. Since i use JavaCPP this step is radically simplified. The annotations are used to give javacpp all the information it needs to prepare its g++ command that in the final compile step will create the library that can be shipped with the java program.

{% raw %}
<pre class="syntax c">
package de.jotschi.javacpp.example;
import static com.googlecode.javacpp.Loader.load;

import com.googlecode.javacpp.Pointer;
import com.googlecode.javacpp.annotation.Name;
import com.googlecode.javacpp.annotation.Platform;

@Platform(include = "Cube.h", link = "Cube")
public class JavaCube {

	NativeCube cube;
	static {
		load();
	}

	public JavaCube() {
		cube = new NativeCube();
	}

	public void setSide(double s) {
		cube.setSide(s);

	}

	public double getArea() {
		return cube.getArea();
	}

	public double getSide() {
		return cube.getSide();
	}

	public double getVolume() {
		return cube.getVolume();
	}

	@Name("Cube")
	public static class NativeCube extends Pointer {

		static {
			load();
		}

		public NativeCube() {
			allocate();
		}

		public NativeCube(Pointer p) {
			super(p);
		}

		public native void setSide(double s);

		// this = new Cube()
		private native void allocate();

		private native double getArea();

		private native double getSide();

		private native double getVolume();

	}
}
</pre>
{% endraw %}

Once the java files have been compiled the exec-maven-plugin will be executed which itself executes the makefile that builds the shared library.
{% raw %} 
<pre class="syntax xml">
	<execution>
		<id>build-sharedlib</id>
		<phase>process-classes</phase>
		<goals>
			<goal>exec</goal>
		</goals>
		<configuration>
			<executable>make</executable>
			<commandlineArgs>main</commandlineArgs>
			<workingDirectory>${basedir}/src/main/jni</workingDirectory>
		</configuration>
	</execution>
</pre>
{% endraw %}

This library will be used within the next execution of the exec-maven-plugin. This final execution step will invoke the javacpp builder which generated the jni headers from the java class annotations and it also compiles the jni header interface against the previously created library.
{% raw %}
<pre class="syntax xml">
	<execution>
		<id>build-jnilib</id>
		<phase>process-classes</phase>
		<goals>
			<goal>exec</goal>
		</goals>
		<configuration>
			<executable>java</executable>
			<commandlineArgs>-jar ../libs/javacpp.jar -Dcompiler.linkpath=${basedir}/target/classes/linux-x86 -Dcompiler.includepath=${basedir}/src/main/jni -classpath target/classes de.jotschi.javacpp.example.JavaCube</commandlineArgs>
		</configuration>
	</execution>
</pre>
{% endraw %}

The CubeTest.java Junit tests shows how the created java class that wraps the native class works.

<h1>javacpp-libc6-example / javacpp-stdlib-example</h1>
These examples are very similar to the javacpp-sharedlib-example. The libc6 example show how to use JavaCPP with the libc6 library and c code. The stdlib example on the other hand uses the c++ stdlib.

<h1>javacpp-android-example</h1>
This example shows how to use a android maven project in combination with JavaCPP. The example shows how to mix java with native code. The java part creates a opengl surface and the native code is used to execute a opengl function that changed the color of the display.
