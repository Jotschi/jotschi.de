<!DOCTYPE html>


<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="alternate" href="/index.xml" type="application/rss+xml" title="Jotschi&#39;s Blog">
		<link rel="icon" href="http://jotschi.de//favicon.ico">
		<title>OpenGL GLU Tesselation Method Without DisplayLists - Jotschi&#39;s Blog</title>
		
		<link rel="stylesheet" href="http://jotschi.de//css/highlight.js.min.css">
		<link rel="stylesheet" href="http://jotschi.de//css/bootstrap.min.css">
		<link rel="stylesheet" href="http://jotschi.de//css/bootstrap-theme.css">
		<link rel="stylesheet" href="http://jotschi.de//css/theme.css">
		<link rel="stylesheet" href="http://jotschi.de//css/bootie-docs.css">
	</head>

<body role="document">

	
	<nav class="navbar navbar-inverse navbar-fixed-top">
		<div class="container">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="http://jotschi.de//">Jotschi&#39;s Blog</a>
			</div>
			<div id="navbar" class="navbar-collapse collapse">
				<ul class="nav navbar-nav">
					<li ><a href="http://jotschi.de//">Home</a></li>
			
				
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Categories<span class="caret"></span></a>
						<ul class="dropdown-menu" role="menu">
						
							<li><a href="http://jotschi.de//categories/code">Code</a></li>
						
							<li><a href="http://jotschi.de//categories/electronics">Electronics</a></li>
						
							<li><a href="http://jotschi.de//categories/gfx">Gfx</a></li>
						
							<li><a href="http://jotschi.de//categories/linux">Linux</a></li>
						
							<li><a href="http://jotschi.de//categories/random">Random</a></li>
						
							<li><a href="http://jotschi.de//categories/space">Space</a></li>
						
						</ul>
					</li>
				
				</ul>
			</div>
		</div>
	</nav>

<div class="container">

<div class="row">
	<div class="col-sm-8 doc-main">
		<main role="main">
			<article>
				<a id="title"></a>
				<h1 class="doc-entry-title">OpenGL GLU Tesselation Method Without DisplayLists</h1>
				<div class="doc-entry-meta">
					<span><time datetime="2009-12-15">December 15, 2009</time></span>
				</div>
				<section>
					<div class="paragraph">
<p>Due to the deprecation of 'DisplayLists' within OpenGL 3.2 i wanted to store my tessellated mesh within a structure which i could use later on. Therefor it is possible to use the GLU_TESS_VERTEX_DATA, GLU_TESS_BEGIN_DATA etc gluTessCallback hooks.</p>
</div>
<div class="paragraph">
<p>When calling the gluTessBeginPolygon method it is possible to pass a address to a own structure along as second argument. This address will be handled to the callback methods and therefor you can access your defined data structure to store the tessellated data within it. My example shows how to deal with that.</p>
</div>
<div class="paragraph">
<p>I use the <a href="http://glm.g-truc.net/about.html">OpenGL Mathematics Library</a> to handle my points.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/images/tesselation/tesselation_star.png" alt="tesselation star"></span></p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/images/tesselation/tesselation_star_wire.png" alt="tesselation star wire"></span></p>
</div>
<div class="paragraph">
<p><em>GL_GLUT_TesselationData.cpp</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;vector&gt;
#include "glm/glm.hpp"
using namespace std;

//#define USEDISPLAYLIST

GLuint startList;
GLdouble **dataOutFinal;

#ifndef USEDISPLAYLIST
struct Mesh {
	std::vector&lt;glm::vec3&gt; points;
	GLenum type;
} mesh;
#endif

GLdouble rect[4][3] = { 50.0, 50.0, 0.0, 200.0, 50.0, 0.0, 200.0, 140.0, 0.0,
		50.0, 200.0, 0.0 };

GLdouble star[5][6] = { 250.0, 50.0, 0.0, 1.0, 0.0, 1.0, 325.0, 200.0, 0.0,
		1.0, 1.0, 0.0, 400.0, 50.0, 0.0, 0.0, 1.0, 1.0, 250.0, 150.0, 0.0, 1.0,
		0.0, 0.0, 400.0, 150.0, 0.0, 0.0, 1.0, 0.0 };

void display(void) {
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(1.0, 0.5, 1.0);

	// Enable this to see the wireframe
	//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

#ifndef USEDISPLAYLIST
	vector&lt;glm::vec3&gt;::const_iterator cii;
	glBegin(mesh.type);
	for (cii = mesh.points.begin(); cii != mesh.points.end(); cii++) {
		glVertex3f((*cii).x, (*cii).y, (*cii).z);
		printf("Result: %f,%f,%f\n", (*cii).x, (*cii).y, (*cii).z);
	}
	glEnd();
#else
	glCallList(startList);
#endif

	glFlush();
}

void beginCallback(GLenum which, void *resultMesh) {
	printf("Type: %i\n", which);
#ifdef USEDISPLAYLIST
	glBegin(which);
#else
	Mesh *myMesh = (Mesh*) resultMesh;
	(*myMesh).type = which;
#endif

}

void errorCallback(GLenum errorCode) {
	const GLubyte *estring;
	estring = gluErrorString(errorCode);
	fprintf(stderr, "Tessellation Error: %s\n", estring);
	exit(0);
}

void endCallback(void *tessellationSetAddress) {
#ifdef USEDISPLAYLIST
	glEnd();
#endif
}

void vertexCallback(GLvoid *data, void *resultMesh) {
	const GLdouble *pointer;
	pointer = (GLdouble *) data;
#ifdef USEDISPLAYLIST
	glColor3dv(pointer + 3);
	glVertex3dv(pointer);
#else
	Mesh *myMesh = (Mesh*) resultMesh;
	(*myMesh).points.push_back(glm::vec3(pointer[0], pointer[1], pointer[2]));
#endif
	printf("Added new vertex[%f][%f][%f]\n", pointer[0], pointer[1], pointer[2]);

}

void combineCallback(GLdouble coords[3], GLdouble *vertex_data[4],
		GLfloat weight[4], GLdouble **dataOut, void *resultMesh) {

	GLdouble *vertex;
	vertex = (GLdouble *) malloc(6 * sizeof(GLdouble));
	vertex[0] = coords[0];
	vertex[1] = coords[1];
	vertex[2] = coords[2];

#ifndef USEDISPLAYLIST
	Mesh *myMesh = (Mesh*) resultMesh;
	(*myMesh).points.push_back(glm::vec3(vertex[0], vertex[1], vertex[2]));
#endif
	printf("Added combine vertex[%f][%f][%f]\n", vertex[0], vertex[1],
			vertex[2]);

	*dataOut = vertex;

}

void init(void) {
	GLUtesselator *tobj;

	glClearColor(0.0, 0.0, 0.0, 0.0);

	tobj = gluNewTess();
	gluTessCallback(tobj, GLU_TESS_VERTEX_DATA, (void(*)()) vertexCallback);
	gluTessCallback(tobj, GLU_TESS_BEGIN_DATA, (void(*)()) beginCallback);
	gluTessCallback(tobj, GLU_TESS_END_DATA, (void(*)()) endCallback);
	gluTessCallback(tobj, GLU_TESS_ERROR, (void(*)()) errorCallback);
	gluTessCallback(tobj, GLU_TESS_COMBINE_DATA, (void(*)()) combineCallback);

#ifdef USEDISPLAYLIST
	startList = glGenLists(1);
	glNewList(startList, GL_COMPILE);
#endif

	glShadeModel(GL_SMOOTH);
	gluTessProperty(tobj, GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_POSITIVE);

#ifdef USEDISPLAYLIST
	gluTessBeginPolygon(tobj, NULL);
#else
	gluTessBeginPolygon(tobj, &amp;mesh);
#endif

	/*
	 gluTessBeginContour(tobj);
	 gluTessVertex(tobj, rect[0], rect[0]);
	 gluTessVertex(tobj, rect[1], rect[1]);
	 gluTessVertex(tobj, rect[2], rect[2]);
	 gluTessVertex(tobj, rect[3], rect[3]);
	 gluTessEndContour(tobj);
	 */

	gluTessBeginContour(tobj);
	gluTessVertex(tobj, star[0], star[0]);
	gluTessVertex(tobj, star[1], star[1]);
	gluTessVertex(tobj, star[2], star[2]);
	gluTessVertex(tobj, star[3], star[3]);
	gluTessVertex(tobj, star[4], star[4]);
	gluTessEndContour(tobj);

	gluTessEndPolygon(tobj);

#ifdef USEDISPLAYLIST
	glEndList();
#endif
	gluDeleteTess(tobj);

	printf("Done\n");

}

void reshape(int w, int h) {
	glViewport(0, 0, (GLsizei) w, (GLsizei) h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0, (GLdouble) w, 0.0, (GLdouble) h);
}

void keyboard(unsigned char key, int x, int y) {
	switch (key) {
	case 27:
		exit(0);
		break;
	}
}

int main(int argc, char** argv) {
	glutInit(&amp;argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(500, 500);
	glutCreateWindow(argv[0]);
	init();
	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
	glutKeyboardFunc(keyboard);
	glutMainLoop();
	return 0;
}</code></pre>
</div>
</div>

				</section>
			</article>
		</main>
	</div> 

	
<div class="col-sm-3 col-sm-offset-1 doc-sidebar">
	<div class="sidebar-module">
		<div class="sidebar-toc">
			<h4>Table of Contents</h4>
			<ul>
				<li><strong><a href="#title">OpenGL GLU Tesselation Method Without DisplayLists</a></strong></li>
			</ul>
			
		</div>
	</div>
	<div class="sidebar-module">
		<h4>Tags</h4>
		<div class="tag-box">
		
		</div>
	</div>
</div>

</div> 


<hr />

<div class="row">
	<div class="col-sm-8">
		<p class="doc-footer-em"><a href="#">Back to TOP</a></p>
	</div>
</div>

</div> 

<footer class="doc-footer">
	
	
</footer>



<script src="http://jotschi.de//js/jquery-1.11.2.min.js"></script>
<script src="http://jotschi.de//js/bootstrap.min.js"></script>

<script src="http://jotschi.de//js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="http://jotschi.de//js/ie10-viewport-bug-workaround.js"></script>

</body>
</html>