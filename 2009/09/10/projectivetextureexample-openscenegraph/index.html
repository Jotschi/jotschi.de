<!DOCTYPE html>


<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="alternate" href="/index.xml" type="application/rss+xml" title="Jotschi&#39;s Blog">
		<link rel="icon" href="http://jotschi.de/favicon.ico">
		<title>ProjectiveTextureExample OpenSceneGraph - Jotschi&#39;s Blog</title>
		
		<link rel="stylesheet" href="http://jotschi.de/css/highlight.js.min.css">
		<link rel="stylesheet" href="http://jotschi.de/css/bootstrap.min.css">
		<link rel="stylesheet" href="http://jotschi.de/css/bootstrap-theme.css">
		<link rel="stylesheet" href="http://jotschi.de/css/theme.css">
		<link rel="stylesheet" href="http://jotschi.de/css/bootie-docs.css">
	</head>

<body role="document">

	
	<nav class="navbar navbar-inverse navbar-fixed-top">
		<div class="container">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="http://jotschi.de/">Jotschi&#39;s Blog</a>
			</div>
			<div id="navbar" class="navbar-collapse collapse">
				<ul class="nav navbar-nav">
					<li ><a href="http://jotschi.de/">Home</a></li>
			
				
					<li class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Categories<span class="caret"></span></a>
						<ul class="dropdown-menu" role="menu">
						
							<li><a href="http://jotschi.de/categories/code">Code</a></li>
						
							<li><a href="http://jotschi.de/categories/electronics">Electronics</a></li>
						
							<li><a href="http://jotschi.de/categories/gfx">Gfx</a></li>
						
							<li><a href="http://jotschi.de/categories/linux">Linux</a></li>
						
							<li><a href="http://jotschi.de/categories/random">Random</a></li>
						
							<li><a href="http://jotschi.de/categories/space">Space</a></li>
						
						</ul>
					</li>
				
				</ul>
			</div>
		</div>
	</nav>

<div class="container">

<div class="row">
	<div class="col-sm-8 doc-main">
		<main role="main">
			<article>
				<a id="title"></a>
				<h1 class="doc-entry-title">ProjectiveTextureExample OpenSceneGraph</h1>
				<div class="doc-entry-meta">
					<span><time datetime="2009-09-10">September 10, 2009</time></span>
				</div>
				<section>
					<div class="paragraph">
<p>Another OSG ProjectiveTexture Example - I did some code cleanup and added a bounding box test feature. My goal this example was to align the projector so that it would cover 100% of the second cameras field of view. In other words the view volume of the perspector of the scene should always be inside of the view volume of the projector. I solved this task by using some bounding box features and by setting the projector view matrix to align the view.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/images/opengl/BoundingBoxedView.png" alt="BoundingBoxedView"></span></p>
</div>
<div class="paragraph">
<p><em>ProjectiveTextureExample.cpp</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#include &lt;iostream&gt;
#include &lt;osg/Notify&gt;
#include &lt;osg/MatrixTransform&gt;
#include &lt;osg/ShapeDrawable&gt;
#include &lt;osg/PositionAttitudeTransform&gt;
#include &lt;osg/Geometry&gt;
#include &lt;osgGA/TrackballManipulator&gt;

#include &lt;osg/Texture2D&gt;
#include &lt;osg/Geode&gt;
#include &lt;osg/LightSource&gt;
#include &lt;osg/TexGenNode&gt;
#include &lt;osg/TexMat&gt;
#include &lt;osgDB/WriteFile&gt;
#include &lt;osgUtil/Optimizer&gt;

#include &lt;osgDB/Registry&gt;
#include &lt;osgDB/ReadFile&gt;

#include &lt;osgViewer/Viewer&gt;
#include &lt;osgViewer/CompositeViewer&gt;
#include &lt;string&gt;
using namespace std;

osgViewer::View* viewA = new osgViewer::View;
osg::TexMat* texMat = new osg::TexMat;

/**
 * This method is used to mark the camera position
 */
osg::Node * markCameraPosition(osg::Camera* camera) {

	osg::Group* root = new osg::Group();
	osg::Matrixd proj;
	osg::Matrixd mv;
	if (camera) {
		proj = camera-&gt;getProjectionMatrix();
		mv = camera-&gt;getViewMatrix();
	} else {
		// Create some kind of reasonable default Projection matrix.
		proj.makePerspective(30., 1., 1., 10.);
		// leave mv as identity
	}

	osg::Vec3f vector = osg::Vec3f(proj(0, 0), proj(0, 0), proj(0, 0));
	osg::Vec3f posVec = osg::Matrixd::inverse(mv).preMult(vector);

	//	printf("VectorX: %f\n", posVec.x());
	//	printf("VectorY: %f\n", posVec.y());
	//	printf("VectorZ: %f\n", posVec.z());

	osg::Sphere* unitSphere = new osg::Sphere(osg::Vec3(0, 0, 0), 2.0);
	osg::ShapeDrawable* unitSphereDrawable = new osg::ShapeDrawable(unitSphere);
	osg::Geode* unitSphereGeode = new osg::Geode();
	unitSphereGeode-&gt;addDrawable(unitSphereDrawable);

	osg::PositionAttitudeTransform* sphereXForm =
			new osg::PositionAttitudeTransform();
	sphereXForm-&gt;setPosition(posVec);
	sphereXForm-&gt;addChild(unitSphereGeode);
	root-&gt;addChild(sphereXForm);

	return root;

}
// Given a Camera, create a wireframe representation of its
// view frustum. Create a default representation if camera==NULL.
osg::Node*
makeFrustumFromCamera(osg::Camera* camera) {

	// Projection and ModelView matrices
	osg::Matrixd proj;
	osg::Matrixd mv;
	if (camera) {
		proj = camera-&gt;getProjectionMatrix();
		mv = camera-&gt;getViewMatrix();
	} else {
		// Create some kind of reasonable default Projection matrix.
		proj.makePerspective(30., 1., 1., 10.);
		// leave mv as identity
	}

	//camera-&gt;setViewMatrix(camera-&gt;getViewMatrix().frustum(100,200,100,100,10,100));

	// Get near and far from the Projection matrix.
	const double near = proj(3, 2) / (proj(2, 2) - 1.0);
	const double far = proj(3, 2) / (1.0 + proj(2, 2));

	// Get the sides of the near plane.
	const double nLeft = near * (proj(2, 0) - 1.0) / proj(0, 0);
	const double nRight = near * (1.0 + proj(2, 0)) / proj(0, 0);
	const double nTop = near * (1.0 + proj(2, 1)) / proj(1, 1);
	const double nBottom = near * (proj(2, 1) - 1.0) / proj(1, 1);

	// Get the sides of the far plane.
	const double fLeft = far * (proj(2, 0) - 1.0) / proj(0, 0);
	const double fRight = far * (1.0 + proj(2, 0)) / proj(0, 0);
	const double fTop = far * (1.0 + proj(2, 1)) / proj(1, 1);
	const double fBottom = far * (proj(2, 1) - 1.0) / proj(1, 1);

	// Our vertex array needs only 9 vertices: The origin, and the
	// eight corners of the near and far planes.
	osg::Vec3Array* v = new osg::Vec3Array;
	v-&gt;resize(9);
	(*v)[0].set(0., 0., 0.);
	(*v)[1].set(nLeft, nBottom, -near);
	(*v)[2].set(nRight, nBottom, -near);
	(*v)[3].set(nRight, nTop, -near);
	(*v)[4].set(nLeft, nTop, -near);
	(*v)[5].set(fLeft, fBottom, -far);
	(*v)[6].set(fRight, fBottom, -far);
	(*v)[7].set(fRight, fTop, -far);
	(*v)[8].set(fLeft, fTop, -far);

	osg::Geometry* geom = new osg::Geometry;
	geom-&gt;setUseDisplayList(false);
	geom-&gt;setVertexArray(v);

	osg::Vec4Array* c = new osg::Vec4Array;
	c-&gt;push_back(osg::Vec4(1., 1., 1., 1.));
	geom-&gt;setColorArray(c);
	geom-&gt;setColorBinding(osg::Geometry::BIND_OVERALL);

	GLushort idxLines[8] = { 0, 5, 0, 6, 0, 7, 0, 8 };
	GLushort idxLoops0[4] = { 1, 2, 3, 4 };
	GLushort idxLoops1[4] = { 5, 6, 7, 8 };
	geom-&gt;addPrimitiveSet(new osg::DrawElementsUShort(osg::PrimitiveSet::LINES,
			8, idxLines));
	geom-&gt;addPrimitiveSet(new osg::DrawElementsUShort(
			osg::PrimitiveSet::LINE_LOOP, 4, idxLoops0));
	geom-&gt;addPrimitiveSet(new osg::DrawElementsUShort(
			osg::PrimitiveSet::LINE_LOOP, 4, idxLoops1));

	osg::Geode* geode = new osg::Geode;
	geode-&gt;addDrawable(geom);

	geode-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF
			| osg::StateAttribute::PROTECTED);

	// Create parent MatrixTransform to transform the view volume by
	// the inverse ModelView matrix.
	osg::MatrixTransform* mt = new osg::MatrixTransform;
	mt-&gt;setMatrix(osg::Matrixd::inverse(mv));
	mt-&gt;addChild(geode);

	return mt;
}

osg::ref_ptr&lt;osg::Program&gt; addShader() {
	osg::ref_ptr&lt;osg::Program&gt; projProg(new osg::Program);
	osg::ref_ptr&lt;osg::Shader&gt; projvertexShader(osg::Shader::readShaderFile(
			osg::Shader::VERTEX, "VertexShader.glsl"));
	osg::ref_ptr&lt;osg::Shader&gt; projfragShader(osg::Shader::readShaderFile(
			osg::Shader::FRAGMENT, "FragmentShader.glsl"));

	projProg-&gt;addShader(projvertexShader.get());
	projProg-&gt;addShader(projfragShader.get());
	return projProg;
}

void addProjectionInfoToState(osg::StateSet* stateset, string fn) {

	/* 1. Load the texture that will be projected */
	osg::Texture2D* texture = new osg::Texture2D();
	texture-&gt;setImage(osgDB::readImageFile(fn));
	texture-&gt;setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_BORDER);
	texture-&gt;setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_BORDER);
	texture-&gt;setWrap(osg::Texture::WRAP_R, osg::Texture::CLAMP_TO_BORDER);
	stateset-&gt;setTextureAttributeAndModes(1, texture, osg::StateAttribute::ON);

	// set up tex gens
	stateset-&gt;setTextureMode(1, GL_TEXTURE_GEN_S, osg::StateAttribute::ON);
	stateset-&gt;setTextureMode(1, GL_TEXTURE_GEN_T, osg::StateAttribute::ON);
	stateset-&gt;setTextureMode(1, GL_TEXTURE_GEN_R, osg::StateAttribute::ON);
	stateset-&gt;setTextureMode(1, GL_TEXTURE_GEN_Q, osg::StateAttribute::ON);

	/* 3. Handover the texture to the fragment shader via uniform */
	osg::Uniform* texUniform = new osg::Uniform(osg::Uniform::SAMPLER_2D,
			"projectionMap");
	texUniform-&gt;set(1);
	stateset-&gt;addUniform(texUniform);

	/* 4. set Texture matrix*/

	//If you want to create the texture matrix by yourself you can do this like this way:
	//osg::Vec3 projectorPos = osg::Vec3(0.0f, 0.0f, 324.0f);
	//osg::Vec3 projectorDirection = osg::Vec3(osg::inDegrees(dirX),osg::inDegrees(dirY), osg::inDegrees(dirZ));
	//osg::Vec3 up(0.0f, 1.0f, 0.0f);
	//osg::Vec3 target = osg::Vec3(0.0f, 0.0f,0.0f);
	//float projectorAngle = 80.f; //FOV
	//mat = osg::Matrixd::lookAt(projectorPos, projectorPos*target ,up) * osg::Matrixd::perspective(projectorAngle, 1.0, 1.0, 10);


	osg::Matrix mat = viewA-&gt;getCamera()-&gt;getViewMatrix()
			* viewA-&gt;getCamera()-&gt;getProjectionMatrix();

	texMat-&gt;setMatrix(mat);
	stateset-&gt;setTextureAttributeAndModes(1, texMat, osg::StateAttribute::ON);

}

osg::StateSet* createProjectorState() {
	osg::StateSet* stateset = new osg::StateSet;
	osg::ref_ptr&lt;osg::Program&gt; prog = addShader();
	addProjectionInfoToState(stateset, "foo2.jpg");
	stateset-&gt;setAttribute(prog.get());
	return stateset;
}

/**
 * Load some model, scale it and apply the shader
 */
osg::Node* createModel() {

	osg::Group* root = new osg::Group;

	/* Load the terrain which will be the receiver of out projection */
	osg::Node* terr = osgDB::readNodeFile("Terrain2.3ds");

	/* Scale the terrain and move it. */
	osg::Matrix m;
	osg::ref_ptr&lt;osg::MatrixTransform&gt; mt = new osg::MatrixTransform;
	m.makeTranslate(0.f, 0.f, 0.f);
	m.makeScale(2.f, 2.f, 2.f);
	mt-&gt;setMatrix(m);
	mt-&gt;addChild(terr);

	/* Add the transformed node to our graph */
	root-&gt;addChild(mt.get());

	/* Enable projective texturing for all objects of this node */
	root-&gt;setStateSet(createProjectorState());
	return root;
}

/**
 * Creates a small ball node for the given coords.
 */
osg::Node* createBall(osg::Vec3 pos) {
	osg::Sphere* unitSphere = new osg::Sphere(osg::Vec3(0, 0, 0), 62.0);
	osg::ShapeDrawable* unitSphereDrawable = new osg::ShapeDrawable(unitSphere);
	osg::Geode* unitSphereGeode = new osg::Geode();
	unitSphereGeode-&gt;addDrawable(unitSphereDrawable);

	osg::PositionAttitudeTransform* sphereXForm =
			new osg::PositionAttitudeTransform();
	sphereXForm-&gt;setPosition(pos);
	sphereXForm-&gt;addChild(unitSphereGeode);
	return sphereXForm;
}

int main(int argc, char ** argv) {

	osg::ArgumentParser arguments(&amp;argc, argv);

	osg::ref_ptr&lt;osg::Group&gt; sceneA = new osg::Group;
	osg::ref_ptr&lt;osg::Group&gt; sceneB = new osg::Group;
	osg::ref_ptr&lt;osg::Group&gt; sceneC = new osg::Group;
	sceneA-&gt;addChild(createModel());
	sceneB-&gt;addChild(createModel());
	sceneC-&gt;addChild(createModel());

	osgViewer::CompositeViewer viewer(arguments);

	// Turn on FSAA, makes the lines look better.
	//osg::DisplaySettings::instance()-&gt;setNumMultiSamples( 4 );

	viewer.addView(viewA);
	viewA-&gt;setUpViewInWindow(10, 10, 640, 480);
	viewA-&gt;setSceneData(sceneA.get());
	//Add this to move the projector by mouse - you need to disable the set of the viewmatrix in the while loop below.
	//viewA-&gt;setCameraManipulator(new osgGA::TrackballManipulator);

	osgViewer::View* viewB = new osgViewer::View;
	viewer.addView(viewB);
	viewB-&gt;setUpViewInWindow(10, 510, 640, 480);
	viewB-&gt;setSceneData(sceneB.get());
	viewB-&gt;setCameraManipulator(new osgGA::TrackballManipulator);

	osgViewer::View* viewC = new osgViewer::View;
	viewer.addView(viewC);
	viewC-&gt;setUpViewInWindow(500, 510, 640, 480);
	viewC-&gt;setSceneData(sceneC.get());
	viewC-&gt;setCameraManipulator(new osgGA::TrackballManipulator);

	// You can disable the auto computed near far bounds by disabling the osg mode.
	// viewer.getView(0)-&gt;getCamera()-&gt;setComputeNearFarMode(osg::Camera::DO_NOT_COMPUTE_NEAR_FAR);


	while (!viewer.done()) {

		osg::Matrix mat = viewA-&gt;getCamera()-&gt;getViewMatrix()
				* viewA-&gt;getCamera()-&gt;getProjectionMatrix();
		texMat-&gt;setMatrix(mat);

		sceneA-&gt;removeChild(1, 1);
		sceneA-&gt;insertChild(1, makeFrustumFromCamera(viewB-&gt;getCamera()));

		//sceneB-&gt;removeChild(1, 1);
		//sceneB-&gt;insertChild(1, makeFrustumFromCamera(viewA-&gt;getCamera()));

		sceneC-&gt;removeChild(1, 1);
		sceneC-&gt;insertChild(1, makeFrustumFromCamera(viewA-&gt;getCamera()));

		sceneC-&gt;removeChild(2, 1);
		sceneC-&gt;insertChild(2, makeFrustumFromCamera(viewB-&gt;getCamera()));

		// Finnaly set the camera
		osg::Node* frustum = makeFrustumFromCamera(viewB-&gt;getCamera());
		const osg::BoundingSphere&amp; boundingSphere = frustum-&gt;getBound();
		osg::Matrix myviewMatrix;
		osg::Vec3 boxEye = boundingSphere._center + osg::Vec3(0.0f, -3.5f
				* boundingSphere._radius, 0.0f);
		osg::Vec3 boxCenter = boundingSphere._center;
		osg::Vec3 boxUp = osg::Vec3(0.0f, 0.0f, 1.0f);
		myviewMatrix.makeLookAt(boxEye, boxCenter, boxUp);
		viewA-&gt;getCamera()-&gt;setViewMatrix(myviewMatrix);

		viewer.frame();
	}
	return 0;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see the texture coordinated will be shifted by 0.5/0.5. I had to do this because the projective center was in the middle of the texture. Without correction you get results like this one:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/images/opengl/texture_projection.png" alt="texture projection"></span></p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/images/opengl/texture_projection_2.png" alt="texture projection 2"></span></p>
</div>
<div class="paragraph">
<p><em>FragmentShader.glsl</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">uniform sampler2D projectionMap;
varying vec4 projCoord;

void main()
{
	vec4 dividedCoord = projCoord / projCoord.w ;
	vec4 color =  texture2D(projectionMap,dividedCoord.st+vec2(0.5,0.5)  );
  	gl_FragColor =	 color * gl_Color;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>VertexShader.glsl</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">varying vec4 projCoord;
void main()
{

		projCoord =  gl_TextureMatrix[1]  *  gl_Vertex;
		gl_Position = ftransform();
		gl_FrontColor = gl_Color;
}</code></pre>
</div>
</div>

				</section>
			</article>
		</main>
	</div> 

	
<div class="col-sm-3 col-sm-offset-1 doc-sidebar">
	<div class="sidebar-module">
		<div class="sidebar-toc">
			<h4>Table of Contents</h4>
			<ul>
				<li><strong><a href="#title">ProjectiveTextureExample OpenSceneGraph</a></strong></li>
			</ul>
			
		</div>
	</div>
	<div class="sidebar-module">
		<h4>Tags</h4>
		<div class="tag-box">
		
        <span class="tag-item"><a href="http://jotschi.de/tags/opengl">#opengl</a></span>
        
		</div>
	</div>
</div>

</div> 


<hr />

<div class="row">
	<div class="col-sm-8">
		<p class="doc-footer-em"><a href="#">Back to TOP</a></p>
	</div>
</div>

</div> 

<footer class="doc-footer">
	
	
</footer>



<script src="http://jotschi.de/js/jquery-1.11.2.min.js"></script>
<script src="http://jotschi.de/js/bootstrap.min.js"></script>

<script src="http://jotschi.de/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="http://jotschi.de/js/ie10-viewport-bug-workaround.js"></script>

</body>
</html>